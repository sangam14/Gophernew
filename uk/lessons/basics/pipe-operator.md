---
version: 1.0.1
title: Оператор конвеєра
---

Оператор конвеєра `|>` передає результат виконання виразу першим параметром в інший вираз.

{% include toc.html %}

## Вступ

Розробка може бути хаотичним процесом. Настільки хаотичним, що виклики функцій стають дуже заплутаними, і їх складно читати. Наприклад, такий вираз:

```elixir
foo(bar(baz(new_function(other_function()))))
```

Тут переданий результат виклику `other_function/0` в `new_function/1`, `new_function/1` в `baz/1`, `baz/1` в `bar/1` і, нарешті, результат виклику `bar/1` стає аргументом `foo/1`. Elixir прагматично підходить до вирішення цієї проблеми шляхом додавання оператора конвеєра. Оператор, що виглядає як `|>` *отримує результат одного виразу, і передає його далі*. Давайте ще раз подивимося на той же приклад, переписаний з використанням цього оператора.

```elixir
other_function() |> new_function() |> baz() |> bar() |> foo()
```

Оператор конвеєра отримує результат виразу зліва і передає його в праву частину.

## Приклади

Для цих прикладів ми будемо користуватися функціями з модуля String.

- Розбиття рядка на слова

```shell
iex> "Elixir rocks" |> String.split()
["Elixir", "rocks"]
```

- Переведення всіх слів рядка в верхній регістр

```shell
iex> "Elixir rocks" |> String.upcase() |> String.split()
["ELIXIR", "ROCKS"]
```

- Перевірка, чи закінчується рядок на "ixir"

```shell
iex> "elixir" |> String.ends_with?("ixir")
true
```

## Поради

Якщо рядок отримує більше одного параметра, використовуйте дужки. Це абсолютно не має значення для мови, але важливо для інших розробників, які можуть неправильно зрозуміти код. Якщо взяти третій приклад і прибрати звідти дужки з виклику `String.ends_with?/2`, виникне попередження:

```shell
iex> "elixir" |> String.ends_with? "ixir"
warning: parentheses are required when piping into a function call. For example:

  foo 1 |> bar 2 |> baz 3

is ambiguous and should be written as

  foo(1) |> bar(2) |> baz(3)

true
```
