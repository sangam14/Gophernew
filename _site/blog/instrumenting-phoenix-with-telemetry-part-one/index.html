<!DOCTYPE HTML>



<html lang="en">
	<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta name="description" content="">
  <meta name="author" content="Sean Callan">

  <meta property="og:url" content="http://localhost:4000/blog/instrumenting-phoenix-with-telemetry-part-one/">
  <meta property="og:site_name" content="ElixirSchool">
  <meta property="og:title" content="">
  <meta property="og:locale" content="">
  <meta property="og:description" content="">
  <meta property="og:image" content="http://localhost:4000/assets/og_image-fad975b316dea5dc361d199bdfaa076006da49a0a3296f799aa7217b4c8b0cbe.jpg">
  
  

  <link rel="canonical" href="http://localhost:4000/blog/instrumenting-phoenix-with-telemetry-part-one/">
  <link rel="apple-touch-icon" sizes="180x180" href="http://localhost:4000/assets/favicons/apple-touch-icon-06ad80501b5734bba0428ca0fc14fcbe45811a144914f7be78cdab3c3ea25458.png">
  <link rel="icon" type="image/png" sizes="32x32" href="http://localhost:4000/assets/favicons/favicon-32x32-6e7b9eca57d29d185a5184e844c1372ce9da0a71f373f89b80ff11f120b01678.png">
  <link rel="icon" type="image/png" sizes="16x16" href="http://localhost:4000/assets/favicons/favicon-16x16-789b56195138252cac40cf7f2425b6fcb4e71c3084abc8525781188781b958d3.png">
  <link rel="manifest" href="http://localhost:4000/manifest.json">
  <link rel="shortcut icon" href="http://localhost:4000/assets/favicons/favicon-8e1fdc2a44d6344b9871b3ecf53a803903891f82a602a3f59c65eda40f2b77b0.ico">
  <link rel="alternate" type="application/rss+xml" title="Elixir School" href="https://elixirschool.com/feed.xml" />
  <meta name="msapplication-config" content="http://localhost:4000/assets/favicons/browserconfig-e66282a6754e6899f9a53c6ebfe120749630242b741deb65f364abc297ccbc96.xml">
  <meta name="theme-color" content="#ffffff">

  
  
  <title>Instrumenting Phoenix with Telemetry Part I: Telemetry Under The Hood &middot; Elixir School</title>
  <!-- CSS -->
  <!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
  <link rel="stylesheet" type="text/css" href="/assets/main-07a5a32c1a26652d2bb0e43b4c7ade37f20599a76cae3c1e871d3af53cff80b2.css">
  <!--[if lte IE 9]><link rel="stylesheet" type="text/css" href="/assets/ie9-0c07c3ea146a3dd5dce4effda97b3718824cab9c30149877c0e445edecfdee60.css"><![endif]-->
  <!--[if lte IE 8]><link rel="stylesheet" type="text/css" href="/assets/ie8-f0c85ce6ad95a6d33929cb969a44f41a5e96ecb22de55f55d0f3c83cfc0012fc.css"><![endif]-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
  <script type="text/javascript">
  !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.1.0";
  analytics.load("C0p07Sw9j7mZnycKDCgPOAyqJR5hhyoQ");
  analytics.page()
  }}();
  </script>
  <script type="text/javascript">
    if ("serviceWorker" in navigator) {
      if (!navigator.serviceWorker.controller) {
        navigator.serviceWorker.register("http://localhost:4000/serviceworker.js", {
          scope: "http://localhost:4000"
        })
        .then(reg => console.log("Service worker has been registered for scope: ", reg.scope))
        .catch(error => console.log("Service worker registration has failed: ", error));
      }
    }  
  </script>
</head>

	<body class="is-loading">
    <script type="text/javascript">
    var $theme = localStorage.getItem('theme');
    if ($theme === 'dark') document.body.classList.add("dark");
    </script>
		<!-- Wrapper -->
		<div id="wrapper">
			<!-- Main -->
			<div id="main">
				<div class="inner">
					<!-- Header -->
					<header id="header">
					  <a href="/" class="logo"><strong>Elixir School</strong> Blog</a>
					  <ul class="icons">
  
  <li><iframe src="https://ghbtns.com/github-btn.html?user=elixirschool&repo=elixirschool&type=star&count=true" height="20" title="GitHub Stars" width="93" style="vertical-align: sub;"></iframe></li>
  <li><a target="_blank" rel="noopener" title="RSS" href="https://elixirschool.com/feed.xml" class="icon fa-rss-square"><span class="label">RSS</span></a></li>
  <li><a target="_blank" rel="noopener" title="LinkedIn" href="https://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/blog/instrumenting-phoenix-with-telemetry-part-one/&title=Instrumenting Phoenix with Telemetry Part I: Telemetry Under The Hood&summary=description&source=http://localhost:4000" class="icon fa-linkedin"><span class="label">Linkedin</span></a></li>
  <li><a target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/intent/tweet?url=http://localhost:4000/blog/instrumenting-phoenix-with-telemetry-part-one/&via=elixirschool&text=ElixirSchool: Instrumenting Phoenix with Telemetry Part I: Telemetry Under The Hood&hashtags=learnelixir%2Celixirlang&" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
  <li><a target="_blank" rel="noopener" title="Facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/blog/instrumenting-phoenix-with-telemetry-part-one/" class="icon fa-facebook"><span class="label">Facebook</span></a></li>
  <li><a target="_blank" rel="noopener" title="Pinterest" href="https://www.pinterest.com/pin/create/link/?url=http://localhost:4000/blog/instrumenting-phoenix-with-telemetry-part-one/&media=http://localhost:4000/assets/og_image-fad975b316dea5dc361d199bdfaa076006da49a0a3296f799aa7217b4c8b0cbe.jpg&description=ElixirSchool: Instrumenting Phoenix with Telemetry Part I: Telemetry Under The Hood" class="icon fa-pinterest"><span class="label">Pinterest</span></a></li>
  <li><a target="_blank" rel="noopener" title="VK" href="https://vk.com/share.php?url=http://localhost:4000/blog/instrumenting-phoenix-with-telemetry-part-one/&title=ElixirSchool: Instrumenting Phoenix with Telemetry Part I: Telemetry Under The Hood&description=Check out 'Instrumenting Phoenix with Telemetry Part I: Telemetry Under The Hood' on ElixirSchool" class="icon fa-vk"><span class="label">VK</span></a></li>
  <li><a target="_blank" rel="noopener" title="Email" href="mailto:?to=&subject=ElixirSchool: Instrumenting Phoenix with Telemetry Part I: Telemetry Under The Hood&body=Check out 'Instrumenting Phoenix with Telemetry Part I: Telemetry Under The Hood' on ElixirSchool%0D%0A%0D%0Ahttp://localhost:4000/blog/instrumenting-phoenix-with-telemetry-part-one/" class="icon fa-envelope"><span class="label">Email</span></a></li>
  <li><a title="Print" href="javascript:window.print()" class="icon fa-print"><span class="label">Print</span></a></li>
</ul>

					</header>
					

<section id="section-page">
  <header class="main">
    <h1 class="post-title">Instrumenting Phoenix with Telemetry Part I: Telemetry Under The Hood</h1>
    <p><a href="/blog/years/2020/">22 Apr 2020</a> · by 

    <a href="https://thegreatcodeadventure.com" target="_blank" rel="nofollow noopener">Sophie DeBenedetto</a> in <a href="/blog/categories/general/">General</a></p>
  </header>
  <div class="content">
    <h2 id="table-of-contents">Table Of Contents</h2>

<p>In this series, we’re instrumenting a Phoenix app and sending metrics to StatsD with the help of Elixir and Erlang’s Telemetry offerings. A brief overview of what we’ll cover:</p>

<ul>
  <li>Part I: Telemetry Under The Hood</li>
  <li><a href="https://elixirschool.com/blog/instrumenting_phoenix_with_telemetry_part_two/">Part II: Handling Telemetry Events with <code class="highlighter-rouge">TelemetryMetrics</code> + <code class="highlighter-rouge">TelemetryMetricsStatsd</code></a></li>
  <li><a href="https://elixirschool.com/blog/instrumenting_phoenix_with_telemetry_part_three/">Part III: Observing Phoenix + Ecto Telemetry Events</a></li>
  <li><a href="https://elixirschool.com/blog/instrumenting-phoenix-with-telemetry-part-four/">Part IV: Erlang VM Measurements with <code class="highlighter-rouge">telemetry_poller</code>, <code class="highlighter-rouge">TelemetryMetrics</code> + <code class="highlighter-rouge">TelemetryMetricsStatsd</code></a></li>
</ul>

<p>In Part I we’ll start out by setting up a basic, DIY Telemetry pipeline and examining how Erlang’s Telemetry library works under the hood. Then, in Part II we’ll take advantage of the <code class="highlighter-rouge">TelemetryMetrics</code> and <code class="highlighter-rouge">TelemetryMetricsStatsd</code> libraries to respond to Telemetry events by formatting them as metrics and reporting those metrics to StatsD. In Part III, we’ll look at the powerful instrumentation that Phoenix and Ecto offer out-of-the-box via Telemetry events executed in source code. Lastly, in Part IV, we’ll leverage the <code class="highlighter-rouge">telemetry_poller</code> Erlang library to take Erlang VM measurements and emit them as Telemetry events, which our Telemetry pipeline can then observe and report on.</p>

<h2 id="introduction">Introduction</h2>

<p>In this post we’ll discuss why observability matters and how Telemetry helps us treat observability like a first class citizen in Elixir projects. Then, we’ll hand-roll our own instrumentation pipeline using Telemetry and StatsD. We’ll wrap up with a look under the hood of the Telemetry library and set ourselves up for Part II of this series, in which we leverage the <code class="highlighter-rouge">Telemetry.Metrics</code> library for even easier instrumentation and reporting.</p>

<h2 id="observability-matters">Observability Matters</h2>

<p>In the immortal words of <a href="https://charity.wtf/2020/03/03/observability-is-a-many-splendored-thing/">Charity Majors</a>, observability means asking ourselves:</p>

<blockquote>
  <p>can you understand what is happening inside the system — can you understand ANY internal state the system may get itself into, simply by asking questions from the outside?</p>
</blockquote>

<p>Anyone who has spent hours (days?) debugging a production issue that they can’t replicate locally, relying mostly on guesswork and institutional knowledge knows what it costs to lack this ability.</p>

<p>Many of us have come to treat this situation as perfectly natural–we’ve come to accept this frustration as part of the job of being a software engineer. We treat observability like something that is out of our hands, or an afterthought–a “nice to have” after the main target of building that new feature or shipping the MVP are hit.</p>

<p>The traditional split between “web developers” and “dev-ops engineers” has lulled us into believing that observability is not the responsibility of the web dev. In the past, it may have been the case that ensuring system observability required a specialized set of skills, but this is increasingly not true of the world we live in.</p>

<p>With third-party tools like Datadog, Splunk and Honeycomb, and libraries like Telemetry, web developers are empowered to treat observability like the first class citizen it is. To paraphrase Charity Majors (again), in today’s world we can instrument our code, watch it deploy, and answer the question: “is it doing what I expect?”. In this way, we can build systems that are “both understandable and well understood”.</p>

<h2 id="telemetry-gives-us-visibility">Telemetry Gives Us Visibility</h2>

<p><a href="https://www.erlang-solutions.com/blog/introducing-telemetry.html">Telemetry</a> is an open source suite of libraries which aims to to unify and standardize how the libraries and applications on the BEAM are instrumented and monitored. How does it work?</p>

<blockquote>
  <p>At the core of Telemetry lies the event. The event indicates that something has happened: an HTTP request was accepted, a database query returned a result, or the user has signed in. Each event can have many handlers attached to it, each performing a specific action when the event is published. For example, an event handler might update a metric, log some data, or enrich a context of distributed trace.</p>
</blockquote>

<p>Telemetry is already included in both Ecto and Phoenix, emitting events that we can opt-in to receiving and acting on accordingly. We can also emit our own custom Telemetry events from our application code and define handlers to respond to them.</p>

<p>The Telemetry events emitted for free from Ecto and Phoenix mean standardized instrumentation for <em>all</em> apps using these libraries. At the same time, the interface that Telemetry provides for handling such events and emitting additional custom events empowers every Elixir developer to hit observability goals by writing and shipping fully instrumented code with ease.</p>

<p>Now that we understand why observability matters and how Telemetry supports observability, let’s dive into the Telemetry library!</p>

<h2 id="using-telemetry-in-elixir">Using Telemetry in Elixir</h2>

<p>First, we’ll take a look at how to set up a simple reporting pipeline for custom Telemetry events in our Phoenix app. Then, we’ll take a look under the hood at the Telemetry library to understand how our pipeline works.</p>

<h3 id="getting-started">Getting Started</h3>

<p>You can follow along with this tutorial by cloning down the repo <a href="https://github.com/elixirschool/telemetry-code-along/tree/part-1-start">here</a>.</p>
<ul>
  <li>Checking out the starting state of our code on the branch <a href="https://github.com/elixirschool/telemetry-code-along/tree/part-1-start">part-1-start</a></li>
  <li>Find the solution code on the branch <a href="https://github.com/elixirschool/telemetry-code-along/tree/part-1-solution">part-1-solution</a></li>
</ul>

<p>Our Phoenix app, Quantum (get it?), is pretty simple–users can sign up, log in and click some buttons. Awesome, right? Really this dummy app just exists to be instrumented so it doesn’t do much, sorry.</p>

<h3 id="overview">Overview</h3>

<p>To get our pipeline up and running we will:</p>

<ul>
  <li>Install the Telemetry library</li>
  <li>Execute a Telemetry event</li>
  <li>Define an event handler module and callback function</li>
  <li>Attach the event to the handler</li>
</ul>

<p>Let’s get started!</p>

<h3 id="what-were-instrumenting">What We’re Instrumenting</h3>

<p>We’ll start by picking a workflow to instrument. But first…</p>

<h4 id="a-note-on-metrics">A Note on Metrics</h4>

<p>In order for us to truly have observability, we need <em>more</em> than visibility into predefined metrics. Metrics are useful for creating static dashboards, monitoring trends over time and establishing alerting thresholds against those trends. Metrics are necessary for us to monitor our system, but since they are pre-aggregated and pre-defined, they <em>don’t</em> achieve true observability. For true observability, we need to be able to ask and answer <em>any</em> question of our running system. So, we want to track and emit events with rich context. Instead of establishing a metric for a specific web request and tracking its count and duration, for example, we want to be able to emit information describing <em>any</em> web request and include rich descriptors of the context of that request–its duration, the endpoint to which it was sent, etc.</p>

<p>Although we want to emit an event for every web request, we’ll start by picking just one endpoint to instrument.</p>

<h4 id="our-custom-telemetry-event">Our Custom Telemetry Event</h4>

<p>Let’s emit a Telemetry event every time a user hits the <code class="highlighter-rouge">/register</code> route and visits the sign up page.</p>

<h3 id="step-1-installing-telemetry">Step 1: Installing Telemetry</h3>

<p>First, we’ll install Telemetry and run <code class="highlighter-rouge">mix deps.get</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># add the following to the `deps` function of your mix.exs file</span>
<span class="p">{</span><span class="ss">:telemetry</span><span class="p">,</span> <span class="s2">"~&gt; 0.4.1"</span><span class="p">}</span>
</code></pre></div></div>

<p>Now we’re ready to emit an event!</p>

<h3 id="step-2-executing-a-telemetry-event">Step 2: Executing a Telemetry Event</h3>

<p>To emit a Telemetry event, we call <a href="https://hexdocs.pm/telemetry/index.html#execute"><code class="highlighter-rouge">:telemetry.execute/3</code></a>. Yep, that’s right, we call on the Erlang <code class="highlighter-rouge">:telemetry</code> module directly from our Elixir code. Elixir/Erlang inter-op FTW!</p>

<p>The <code class="highlighter-rouge">execute/3</code> function takes in three arguments–the name of the event, the measurements we’re using to describe that event and any metadata that describes the event context.</p>

<p>We’ll emit the following event, with the name <code class="highlighter-rouge">[:phoenix, :request]</code>, from the <code class="highlighter-rouge">new</code> function of our <code class="highlighter-rouge">UserController</code>.</p>

<p>Our event:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">QuantumWeb</span><span class="o">.</span><span class="no">UserController</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">QuantumWeb</span><span class="p">,</span> <span class="ss">:controller</span>

  <span class="n">alias</span> <span class="no">Quantum</span><span class="o">.</span><span class="no">Accounts</span>
  <span class="n">alias</span> <span class="no">Quantum</span><span class="o">.</span><span class="no">Accounts</span><span class="o">.</span><span class="no">User</span>

  <span class="k">def</span> <span class="n">new</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_params</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">start</span> <span class="o">=</span> <span class="no">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span>
    <span class="n">changeset</span> <span class="o">=</span> <span class="no">Accounts</span><span class="o">.</span><span class="n">change_user</span><span class="p">(%</span><span class="no">User</span><span class="p">{})</span>

    <span class="ss">:telemetry</span><span class="o">.</span><span class="n">execute</span><span class="p">([</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="ss">:request</span><span class="p">],</span> <span class="p">%{</span><span class="ss">duration:</span> <span class="no">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">},</span> <span class="n">conn</span><span class="p">)</span>

    <span class="n">render</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="s2">"new.html"</span><span class="p">,</span> <span class="ss">changeset:</span> <span class="n">changeset</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here, we’re emitting an event that includes the duration measurement–tracking the duration of the web request–along with the context of the web request, described by the <code class="highlighter-rouge">conn</code> struct.</p>

<h3 id="step-3-defining-and-attaching-the-telemetry-handler">Step 3: Defining and Attaching The Telemetry Handler</h3>

<p>We need to define a handler that implements a callback function that will be invoked when our event is executed.</p>

<p>The callback function will match the specific event we’re emitting using <a href="https://medium.com/flatiron-labs/how-functions-pattern-match-in-elixir-12a44a51c6ad">function arity pattern matching</a>.</p>

<p>Let’s define a module, <code class="highlighter-rouge">Quantum.Telemetry.Metrics</code>, that implements a function, <code class="highlighter-rouge">handle_event/4</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/quantum/telemetry/metrics.ex</span>
<span class="k">defmodule</span> <span class="no">Quantum</span><span class="o">.</span><span class="no">Telemetry</span><span class="o">.</span><span class="no">Metrics</span> <span class="k">do</span>
  <span class="kn">require</span> <span class="no">Logger</span>
  <span class="n">alias</span> <span class="no">Quantum</span><span class="o">.</span><span class="no">Telemetry</span><span class="o">.</span><span class="no">StatsdReporter</span>

  <span class="k">def</span> <span class="n">handle_event</span><span class="p">([</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="ss">:request</span><span class="p">],</span> <span class="p">%{</span><span class="ss">duration:</span> <span class="n">dur</span><span class="p">},</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">_config</span><span class="p">)</span> <span class="k">do</span>
    <span class="c1"># do some stuff like log a message or report metrics to a service like StatsD</span>
    <span class="no">Logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"Received [:phoenix, :request] event. Request duration: </span><span class="si">#{</span><span class="n">dur</span><span class="si">}</span><span class="s2">, Route: </span><span class="si">#{</span><span class="n">metadata</span><span class="o">.</span><span class="n">request_path</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="step-4-attaching-the-event-to-the-handler">Step 4: Attaching the Event to the Handler</h3>

<p>In order for this module’s <code class="highlighter-rouge">handle_event/4</code> function to be called when our <code class="highlighter-rouge">[:phoenix, :request]</code> event is executed, we need to “attach” the handler to the event.</p>

<p>We do that with the help of Telemetry’s <a href="https://hexdocs.pm/telemetry/index.html#attach"><code class="highlighter-rouge">attach/4</code></a> function.</p>

<p>The <code class="highlighter-rouge">attach/4</code> function takes in four arguments:</p>

<ul>
  <li>A unique “handler ID” that will be used to look up the handler for the event later</li>
  <li>The event name</li>
  <li>The handler callback function</li>
  <li>Any handler config (which we don’t need to take advantage of for the purposes of our example)</li>
</ul>

<p>We’ll call this function in our application’s <code class="highlighter-rouge">start/2</code> function:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/quantum/application.ex</span>

<span class="k">def</span> <span class="n">start</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">do</span>
  <span class="ss">:ok</span> <span class="o">=</span> <span class="ss">:telemetry</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span>
    <span class="c1"># unique handler id</span>
    <span class="s2">"quantum-telemetry-metrics"</span><span class="p">,</span>
    <span class="p">[</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="ss">:request</span><span class="p">],</span>
    <span class="o">&amp;</span><span class="no">Quantum</span><span class="o">.</span><span class="no">Telemetry</span><span class="o">.</span><span class="no">Metrics</span><span class="o">.</span><span class="n">handle_event</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span>
    <span class="no">nil</span>
  <span class="p">)</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now that we’ve defined and emitted our event, and attached a handler to that event, the following will occur:</p>

<ul>
  <li>When a user visit the <code class="highlighter-rouge">/register</code> route and hits the <code class="highlighter-rouge">new</code> action of the <code class="highlighter-rouge">UserController</code></li>
  <li>We’ll emit the Telemetry event, including the request duration and the <code class="highlighter-rouge">conn</code> like this:<code class="highlighter-rouge">:telemetry.execute([:phoenix, :request], %{duration: System.monotonic_time() - start}, conn)</code></li>
  <li>Then our <code class="highlighter-rouge">Quantum.Telemetry.Metrics.handle_event/4</code> function will be invoked, with the arguments of the event name, the measurement map including the request duration, and the measurement metadata, for which we passed in the <code class="highlighter-rouge">conn</code>.</li>
</ul>

<p>So, if we run the server with <code class="highlighter-rouge">mix phx.server</code>, and visit <code class="highlighter-rouge">http://localhost:4000/register/new</code>, we should see the following logged to our terminal:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[info] Received [:phoenix, :request] event. Request duration: 18000, Route: /register/new
</code></pre></div></div>

<p>This log statement is just one example of what we could do to respond to the Telemetry event. Later on, we’ll use the information in this event to report a metric to StatsD.</p>

<p>Next up, we’ll take a look under the hood of the Telemetry library to understand how emitting our event results in the invocation of our handler.</p>

<h2 id="telemetry-under-the-hood">Telemetry Under The Hood</h2>

<p>How does Telemetry invoke our handler callback function when an event is emitted? It leverages ETS! Telemetry stores our event and associated handler in an ETS table when we call <code class="highlighter-rouge">:telemetry.attach/4</code>. When we call <code class="highlighter-rouge">:telemetry.execute/3</code>, Telemetry looks up the handler function for the given event in the ETS table and executes it.</p>

<p>In the next sections, we’ll walk through some Telemetry source code so get a better understanding of how this process works. If you’re new to Erlang (like me!), no problem. Just do your best to read through the code for a high-level understanding.</p>

<h3 id="attaching-handlers-to-events">Attaching Handlers to Events</h3>

<p>The <code class="highlighter-rouge">:telemetry.attach/4</code> function stores the handler and its associated events in an ETS table, under the unique handler ID we provide.</p>

<p>If we peek at the <code class="highlighter-rouge">attach/4</code> source code, we can see the call to insert into ETS <a href="https://github.com/beam-telemetry/telemetry/blob/master/src/telemetry.erl#L89">here</a></p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">% telemetry/src/telemetry.erl
% inside the attach/4 function:
</span>
<span class="nn">telemetry_handler_table</span><span class="p">:</span><span class="nf">insert</span><span class="p">(</span><span class="nv">HandlerId</span><span class="p">,</span> <span class="nv">EventNames</span><span class="p">,</span> <span class="nv">Function</span><span class="p">,</span> <span class="nv">Config</span><span class="p">).</span>
</code></pre></div></div>

<p>Looking at the <a href="https://github.com/beam-telemetry/telemetry/blob/master/src/telemetry_handler_table.erl#L65"><code class="highlighter-rouge">telemetry_handler_table</code> source code</a>, we can see that the handler is stored in the ETS table like this:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">% telemetry/src/telemetry_handler_table.erl
% inside the insert/5 function:
</span>
<span class="nv">Objects</span> <span class="o">=</span> <span class="p">[</span><span class="nl">#handler</span><span class="p">{</span><span class="n">id</span><span class="o">=</span><span class="nv">HandlerId</span><span class="p">,</span>
            <span class="n">event_name</span><span class="o">=</span><span class="nv">EventName</span><span class="p">,</span>
            <span class="n">function</span><span class="o">=</span><span class="nv">Function</span><span class="p">,</span>
            <span class="n">config</span><span class="o">=</span><span class="nv">Config</span><span class="p">}</span> <span class="p">||</span> <span class="nv">EventName</span> <span class="o">&lt;-</span> <span class="nv">EventNames</span><span class="p">],</span>
            <span class="nn">ets</span><span class="p">:</span><span class="nf">insert</span><span class="p">(</span><span class="o">?</span><span class="nv">MODULE</span><span class="p">,</span> <span class="nv">Objects</span><span class="p">)</span>
</code></pre></div></div>

<p>So, each handler is stored in ETS with the format:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="n">id</span><span class="o">=</span><span class="nv">HandlerId</span><span class="p">,</span>
  <span class="n">event_name</span><span class="o">=</span><span class="nv">EventName</span><span class="p">,</span>
  <span class="n">function</span><span class="o">=</span><span class="nv">HandlerFunction</span><span class="p">,</span>
  <span class="n">config</span><span class="o">=</span><span class="nv">Config</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Where the <code class="highlighter-rouge">HandlerId</code> <code class="highlighter-rouge">EventName</code>, <code class="highlighter-rouge">HandlerFunction</code> and <code class="highlighter-rouge">Config</code> are set to whatever we passed into our call to <code class="highlighter-rouge">:telemetry.attach/4</code>.</p>

<h3 id="executing-events">Executing Events</h3>

<p>When we call <code class="highlighter-rouge">:telemetry.execute/3</code>, Telemetry will look up the handler by the event name and invoke its callback function. Let’s take a look at the source code for <code class="highlighter-rouge">:telemetry.execute/3</code> <a href="https://github.com/beam-telemetry/telemetry/blob/master/src/telemetry.erl#L108">here</a>:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">% telemetry/src/telemetry.erl
</span>
<span class="p">-</span><span class="ni">spec</span> <span class="nf">execute</span><span class="p">(</span><span class="nv">EventName</span><span class="p">,</span> <span class="nv">Measurements</span><span class="p">,</span> <span class="nv">Metadata</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ok</span> <span class="k">when</span>
     <span class="nv">EventName</span> <span class="p">::</span> <span class="nf">event_name</span><span class="p">(),</span>
     <span class="nv">Measurements</span> <span class="p">::</span> <span class="nf">event_measurements</span><span class="p">()</span> <span class="p">|</span> <span class="nf">event_value</span><span class="p">(),</span>
     <span class="nv">Metadata</span> <span class="p">::</span> <span class="nf">event_metadata</span><span class="p">().</span>
<span class="nf">execute</span><span class="p">(</span><span class="nv">EventName</span><span class="p">,</span> <span class="nv">Value</span><span class="p">,</span> <span class="nv">Metadata</span><span class="p">)</span> <span class="k">when</span> <span class="nb">is_number</span><span class="p">(</span><span class="nv">Value</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="o">?</span><span class="nv">LOG_WARNING</span><span class="p">(</span><span class="s">"Using execute/3 with a single event value is deprecated. "</span>
                <span class="s">"Use a measurement map instead."</span><span class="p">,</span> <span class="p">[]),</span>
   <span class="nf">execute</span><span class="p">(</span><span class="nv">EventName</span><span class="p">,</span> <span class="err">#</span><span class="p">{</span><span class="n">value</span> <span class="o">=&gt;</span> <span class="nv">Value</span><span class="p">},</span> <span class="nv">Metadata</span><span class="p">);</span>
<span class="nf">execute</span><span class="p">(</span><span class="nv">EventName</span><span class="p">,</span> <span class="nv">Measurements</span><span class="p">,</span> <span class="nv">Metadata</span><span class="p">)</span> <span class="k">when</span> <span class="nf">is_map</span><span class="p">(</span><span class="nv">Measurements</span><span class="p">)</span> <span class="ow">and</span> <span class="nf">is_map</span><span class="p">(</span><span class="nv">Metadata</span><span class="p">)</span> <span class="o">-&gt;</span>
   <span class="nv">Handlers</span> <span class="o">=</span> <span class="nn">telemetry_handler_table</span><span class="p">:</span><span class="nf">list_for_event</span><span class="p">(</span><span class="nv">EventName</span><span class="p">),</span>
   <span class="nv">ApplyFun</span> <span class="o">=</span>
       <span class="k">fun</span><span class="p">(</span><span class="nl">#handler</span><span class="p">{</span><span class="n">id</span><span class="o">=</span><span class="nv">HandlerId</span><span class="p">,</span>
                    <span class="n">function</span><span class="o">=</span><span class="nv">HandlerFunction</span><span class="p">,</span>
                    <span class="n">config</span><span class="o">=</span><span class="nv">Config</span><span class="p">})</span> <span class="o">-&gt;</span>
           <span class="k">try</span>
               <span class="nv">HandlerFunction</span><span class="p">(</span><span class="nv">EventName</span><span class="p">,</span> <span class="nv">Measurements</span><span class="p">,</span> <span class="nv">Metadata</span><span class="p">,</span> <span class="nv">Config</span><span class="p">)</span>
           <span class="k">catch</span>
               <span class="o">?</span><span class="nv">WITH_STACKTRACE</span><span class="p">(</span><span class="nv">Class</span><span class="p">,</span> <span class="nv">Reason</span><span class="p">,</span> <span class="nv">Stacktrace</span><span class="p">)</span>
                   <span class="nf">detach</span><span class="p">(</span><span class="nv">HandlerId</span><span class="p">),</span>
                   <span class="o">?</span><span class="nv">LOG_ERROR</span><span class="p">(</span><span class="s">"Handler </span><span class="si">~p</span><span class="s"> has failed and has been detached. "</span>
                              <span class="s">"Class=</span><span class="si">~p~n</span><span class="s">Reason=</span><span class="si">~p~n</span><span class="s">Stacktrace=</span><span class="si">~p~n</span><span class="s">"</span><span class="p">,</span>
                              <span class="p">[</span><span class="nv">HandlerId</span><span class="p">,</span> <span class="nv">Class</span><span class="p">,</span> <span class="nv">Reason</span><span class="p">,</span> <span class="nv">Stacktrace</span><span class="p">])</span>
           <span class="k">end</span>
       <span class="k">end</span><span class="p">,</span>
   <span class="nn">lists</span><span class="p">:</span><span class="nf">foreach</span><span class="p">(</span><span class="nv">ApplyFun</span><span class="p">,</span> <span class="nv">Handlers</span><span class="p">).</span>
</code></pre></div></div>

<p>Let’s break down this process:</p>

<h4 id="first-look-up-the-handlers-for-the-event-in-ets">First, look up the handlers for the event in ETS:</h4>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">% telemetry/src/telemetry.erl
</span>
<span class="nv">Handlers</span> <span class="o">=</span> <span class="nn">telemetry_handler_table</span><span class="p">:</span><span class="nf">list_for_event</span><span class="p">(</span><span class="nv">EventName</span><span class="p">)</span>
</code></pre></div></div>

<p>Looking at the <a href="https://github.com/beam-telemetry/telemetry/blob/master/src/telemetry_handler_table.erl#L45"><code class="highlighter-rouge">telemetry_handler_table.list_for_event/1</code> source code</a>, we can see that the handler is looked up in ETS by the given event name like this:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">% telemetry/src/telemetry_handler_table.erl
% inside list_for_event/1
</span>
<span class="nn">ets</span><span class="p">:</span><span class="nf">lookup</span><span class="p">(</span><span class="o">?</span><span class="nv">MODULE</span><span class="p">,</span> <span class="nv">EventName</span><span class="p">)</span>
</code></pre></div></div>

<p>This will return the list of stored handlers for the event, where each handler will know its handle ID, handle function and any config:</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="n">id</span><span class="o">=</span><span class="nv">HandlerId</span><span class="p">,</span>
  <span class="n">function</span><span class="o">=</span><span class="nv">HandlerFunction</span><span class="p">,</span>
  <span class="n">config</span><span class="o">=</span><span class="nv">Config</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="then-establish-an-applyfun-to-be-called-for-each-handler">Then, establish an <code class="highlighter-rouge">ApplyFun</code> to be called for each handler</h4>

<p>The <code class="highlighter-rouge">ApplyFun</code> will invoke the given handler’s <code class="highlighter-rouge">HandleFunction</code> with the event, measurements and metadata passed in via the call to <code class="highlighter-rouge">:telemetry.execute/3</code>, along with any config that was stored in ETS.</p>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">% telemetry/src/telemetry.erl
</span>
<span class="nv">ApplyFun</span> <span class="o">=</span>
  <span class="k">fun</span><span class="p">(</span><span class="nl">#handler</span><span class="p">{</span><span class="n">id</span><span class="o">=</span><span class="nv">HandlerId</span><span class="p">,</span>
               <span class="n">function</span><span class="o">=</span><span class="nv">HandlerFunction</span><span class="p">,</span>
               <span class="n">config</span><span class="o">=</span><span class="nv">Config</span><span class="p">})</span> <span class="o">-&gt;</span>
      <span class="k">try</span>
          <span class="nv">HandlerFunction</span><span class="p">(</span><span class="nv">EventName</span><span class="p">,</span> <span class="nv">Measurements</span><span class="p">,</span> <span class="nv">Metadata</span><span class="p">,</span> <span class="nv">Config</span><span class="p">)</span>
      <span class="k">catch</span>
          <span class="o">?</span><span class="nv">WITH_STACKTRACE</span><span class="p">(</span><span class="nv">Class</span><span class="p">,</span> <span class="nv">Reason</span><span class="p">,</span> <span class="nv">Stacktrace</span><span class="p">)</span>
              <span class="nf">detach</span><span class="p">(</span><span class="nv">HandlerId</span><span class="p">),</span>
              <span class="o">?</span><span class="nv">LOG_ERROR</span><span class="p">(</span><span class="s">"Handler </span><span class="si">~p</span><span class="s"> has failed and has been detached. "</span>
                         <span class="s">"Class=</span><span class="si">~p~n</span><span class="s">Reason=</span><span class="si">~p~n</span><span class="s">Stacktrace=</span><span class="si">~p~n</span><span class="s">"</span><span class="p">,</span>
                         <span class="p">[</span><span class="nv">HandlerId</span><span class="p">,</span> <span class="nv">Class</span><span class="p">,</span> <span class="nv">Reason</span><span class="p">,</span> <span class="nv">Stacktrace</span><span class="p">])</span>
      <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<h4 id="lastly-iterate-over-the-handlers-and-invoke-the-applyfun-for-each-handler">Lastly, iterate over the <code class="highlighter-rouge">Handlers</code> and invoke the <code class="highlighter-rouge">ApplyFun</code> for each handler</h4>

<div class="language-erlang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">lists</span><span class="p">:</span><span class="nf">foreach</span><span class="p">(</span><span class="nv">ApplyFun</span><span class="p">,</span> <span class="nv">Handlers</span><span class="p">).</span>
</code></pre></div></div>

<p>And that’s it!</p>

<h4 id="putting-it-all-together">Putting It All Together</h4>

<p>To summarize, when we “attach” an event to a handler, we are storing the handler and its callback function in ETS under that event name. Later, when an event is “executed”, Telemetry looks up the handler for the event and executes the callback function. Pretty simple.</p>

<p>Now that we understand how our Telemetry pipeline works, we’re ready to consider the last piece of the puzzle: event reporting.</p>

<h3 id="reporting-events-to-statsd">Reporting Events to StatsD</h3>

<p>What you do with your event is up to you, but one common strategy is to report metrics to StatsD. In this example, we’ll use the <a href="https://github.com/lexmag/statix"><code class="highlighter-rouge">Statix</code></a> library to report metrics describing our event to StatsD.</p>

<p>First, we’ll install Statix and run <code class="highlighter-rouge">mix deps.get</code></p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># add the following to the `deps` function of your mix.exs file</span>
<span class="p">{</span><span class="ss">:statix</span><span class="p">,</span> <span class="s2">"&gt;= 0.0.0"</span><span class="p">}</span>
</code></pre></div></div>

<p>Next up, we define a module that uses <code class="highlighter-rouge">Statix</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/quantum/telemetry/statsd_reporter.ex</span>
<span class="k">defmodule</span> <span class="no">Quantum</span><span class="o">.</span><span class="no">Telemetry</span><span class="o">.</span><span class="no">StatsdReporter</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Statix</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We need to start the <code class="highlighter-rouge">StatsdReporter</code> in our application’s <code class="highlighter-rouge">start/2</code> function:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/quantum/application.ex</span>
<span class="k">def</span> <span class="n">start</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">do</span>
  <span class="ss">:ok</span> <span class="o">=</span> <span class="no">Quantum</span><span class="o">.</span><span class="no">Telemetry</span><span class="o">.</span><span class="no">StatsdReporter</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
  <span class="ss">:ok</span> <span class="o">=</span> <span class="ss">:telemetry</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span>
    <span class="c1"># unique handler id</span>
    <span class="s2">"quantum-telemetry-metrics"</span><span class="p">,</span>
    <span class="p">[</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="ss">:request</span><span class="p">],</span>
    <span class="o">&amp;</span><span class="no">Quantum</span><span class="o">.</span><span class="no">Telemetry</span><span class="o">.</span><span class="no">Metrics</span><span class="o">.</span><span class="n">handle_event</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span>
    <span class="no">nil</span>
  <span class="p">)</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now we can call on our <code class="highlighter-rouge">Quantum.Telemetry.StatsdReporter</code> in our event handler to emit metrics to StatsD:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/quantum/telemetry/metrics.ex</span>
<span class="k">defmodule</span> <span class="no">Quantum</span><span class="o">.</span><span class="no">Telemetry</span><span class="o">.</span><span class="no">Metrics</span> <span class="k">do</span>
  <span class="kn">require</span> <span class="no">Logger</span>
  <span class="n">alias</span> <span class="no">Quantum</span><span class="o">.</span><span class="no">Telemetry</span><span class="o">.</span><span class="no">StatsdReporter</span>

  <span class="k">def</span> <span class="n">handle_event</span><span class="p">([</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="ss">:request</span><span class="p">],</span> <span class="p">%{</span><span class="ss">duration:</span> <span class="n">dur</span><span class="p">},</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">_config</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">StatsdReporter</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="s2">"phoenix.request.success"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="no">StatsdReporter</span><span class="o">.</span><span class="n">timing</span><span class="p">(</span><span class="s2">"phoenix.request.success"</span><span class="p">,</span> <span class="n">dur</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here, we’re reporting a counter metric that tracks the number of such request events, as well as a timing metric that tracks the duration of web requests.</p>

<p>Now, if we run our app and visit the <code class="highlighter-rouge">/register</code> route a few times, we should see the following emitted to StatsD:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  counters: {
    'quantum.phoenix.request': 7
  },
  timers: {
    'quantum.phoenix.request': [
      18000, 18000,
      19000, 19000,
      20000, 22000,
      24000
    ]
  },
  timer_data: {
    'quantum.phoenix.request': {
      count_90: 6,
      mean_90: 19333.333333333332,
      upper_90: 22000,
      sum_90: 116000,
      sum_squares_90: 2254000000,
      std: 2070.1966780270627,
      upper: 24000,
      lower: 18000,
      count: 7,
      count_ps: 0.7,
      sum: 140000,
      sum_squares: 2830000000,
      mean: 20000,
      median: 19000
    }
  },
  counter_rates: {
    'quantum.phoenix.request': 0.7
  }
}
</code></pre></div></div>

<p><em>NOTE: To install and run StatsD locally follow the simple guide <a href="https://anomaly.io/statsd-install-and-config/index.html">here</a>.</em></p>

<p>This reporting leaves something to be desired. We’re not currently taking advantage of the request context, passed into the <code class="highlighter-rouge">handle_event/4</code> function as the <code class="highlighter-rouge">metadata</code> argument. This metric alone is not very helpful from an observability standpoint since it doesn’t tell us anything about which endpoint received the request, who sent it and what the response was.</p>

<p>We have two options here. We can emit a more specific event from our controller, something like:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">:telemetry</span><span class="o">.</span><span class="n">execute</span><span class="p">([</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="ss">:request</span><span class="p">,</span> <span class="ss">:register</span><span class="p">],</span> <span class="p">%{</span><span class="ss">duration:</span> <span class="no">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">},</span> <span class="n">conn</span><span class="p">)</span>
</code></pre></div></div>

<p>This leaves us on the hook for defining and emitting custom events <em>from every controller action</em>. Soon it will be hard to keep track of and standardize all of these events.</p>

<p>We could instead add some tags to the metric we are sending to StatsD in the event handler:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">StatsdReporter</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="s2">"phoenix.request.success"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">tags:</span> <span class="p">[</span><span class="n">metadata</span><span class="o">.</span><span class="n">request_path</span><span class="p">])</span>
<span class="no">StatsdReporter</span><span class="o">.</span><span class="n">timing</span><span class="p">(</span><span class="s2">"phoenix.request.success"</span><span class="p">,</span> <span class="n">dur</span><span class="p">,</span> <span class="ss">tags:</span> <span class="p">[</span><span class="n">metadata</span><span class="o">.</span><span class="n">request_path</span><span class="p">])</span>
</code></pre></div></div>

<p>The standard StatsD agent does not support tagging, and will error if we use tags here. However, if you are reporting to the DogStatsD agent with the goal of sending metrics to Datadog, your tags will be successfully applied like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>quantum.phoenix.request:1|c|#/register/new
quantum.phoenix.request:21000|ms|#/register/new
</code></pre></div></div>

<p>We won’t dig into solving this problem now. Instead, we’re highlighting the fact that metrics reporting is complex. It’s a hard problem to solve and we could easily throw many hours and lots of code at it.</p>

<h3 id="conclusion">Conclusion</h3>

<p>This seems hard. Is this too hard?</p>

<p>Telemetry provides a simple interface for instrumentation, but our barebones example leaves a lot to be desired. Earlier, we identified a need to instrument and report on <em>all</em> of the web requests received by our app. We want to be able to aggregate and analyze metrics describing the request times and counts across our web application, and we want the data we emit describing these data points to be information rich so that we can slice it by endpoint, response status and more. In this way, our app becomes <em>observable</em>, i.e. its outputs can tell use about its state.</p>

<p>In our current approach, however, we are manually emitting <em>just one Telemetry event</em> for <em>one specific endpoint</em>. This approach leaves us on the hook for manually emitting Telemetry events for <em>every</em> request, from <em>every endpoint</em>.</p>

<p>Our reporting mechanism, currently set up to send metrics to StatsD, is also a little problematic. Not only did we have to do the work to setup our own reporter, with the help of the <code class="highlighter-rouge">Statix</code> library, we’re not properly taking advantage of tagging or our rich event context. We’ll have to do additional work to utilize our event context, either through tagging with a DogStatsD reporter (even more work to set up a whole new reporter!) or by updating the name of the event itself.</p>

<p>“Wait a minute”, you might be thinking, “I thought Telemetry was supposed to standardize instrumentation events and make it fast and easy to operate on and report those events. Why do I <em>still</em> have to emit <em>all</em> my own events and be on the hook for <em>all</em> of my reporting needs?”</p>

<h3 id="next-up">Next Up</h3>

<p>Well the answer is, you <em>don’t</em> have to emit all of your own events <em>or</em> be responsible for all of your reporting! Now that we understand <em>how</em> to set up a Telemetry pipeline, and how it works under the hood to store and execute callbacks for events using ETS, we’re ready to rely on some handy abstractions that additional Telemetry libraries provide.</p>

<p>Surprise! Phoenix and Ecto are <em>already</em> emitting common events from source code, including request counts and duration. The <code class="highlighter-rouge">Telemetry.Metrics</code> library will make it super easy for us to hook into these events without defining and attaching our own handlers.</p>

<p>Further, Telemetry provides a number of reporting clients, including a StatsD reporter, that we can plug into our <code class="highlighter-rouge">Telemetry.Metrics</code> module for free metrics reporting to StatsD <em>or</em> DogStatsD, allowing us to take advantage of event metadata with tagging.</p>

<p>In the <a href="https://elixirschool.com/blog/instrumenting_phoenix_with_telemetry_part_two/">next post</a>, we’ll leverage <code class="highlighter-rouge">Telemetry.Metrics</code> and the <code class="highlighter-rouge">TelemetryStatsdReporter</code> to observe, format and report the Telemetry event we established here. In doing so, we’ll abstract away the need for our custom handler <em>and</em> our custom StatsD reporter.</p>

<p>See you soon!</p>

    

    <blockquote class="edit-lesson">
      Caught a mistake or want to contribute to the article?
      <a href="https://github.com/elixirschool/elixirschool/edit/master/_posts/2020-04-22-instrumenting-phoenix-with-telemetry-part-one.md" target="_blank" rel="noopener">
        Edit this page on GitHub!
      </a>
    </blockquote>
  </div>
</section>
<section class="section-prevnext">
  <div class="row">
    <div class="6u 12u$(small)">
      
        <h4 class="title is-7 has-text-grey-light">Previous article</h4>
        <a class="button special fit" href="http://localhost:4000/blog/live-view-live-component/" title="LiveView Design Patterns - LiveComponent and the Single Responsibility Principle" rel="prev">&laquo; LiveView Design Patterns - LiveComponent and th...</a>
      
    </div>
    <div class="6u 12u$(small)">
      
        <h4>Next article</h4>
        <a class="button special fit" href="http://localhost:4000/blog/instrumenting-phoenix-with-live-dashboard/" title="Instrumenting Phoenix with Telemetry and LiveDashboard" rel="next">Instrumenting Phoenix with Telemetry and LiveDa... &raquo;</a>
      
    </div>
  </div>
</section>

<section>

    
  
    <div class="row profile">
  <div class="1u 2u(medium) 12u$(small)"><img src="https://github.com/SophieDeBenedetto.png" alt="" style="max-width: 60px;"></div>
  <div class="11u 10u(medium) 12u$(small)">
    <h2>
    
      <a href="https://github.com/SophieDeBenedetto">Sophie DeBenedetto</a>
    
    </h2>
    <p class="content">Sophie is an engineer and teacher at The Flatiron School. She loves teaching and learning and finding the Elixir School community felt like the perfect fit!</p>
    <ul class="icons">
      
      <li><a href="https://thegreatcodeadventure.com" class="icon fa-globe"><span class="label">Homepage</span></a></li>
      
      
      <li><a href="https://twitter.com/sm_debenedetto" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
      
      <li><a href="https://github.com/SophieDeBenedetto" class="icon fa-github"><span class="label">Github</span></a></li>
    </ul>
  </div>
</div>

  
</section>

				</div>
			</div>
			<!-- Sidebar -->
  <div id="sidebar">
    <p class="toggle-theme-wrapper"><a rel="noopener" href="#toggle-theme" class="toggle-theme icon fas fa-circle-o" alt="Toggle Theme" title="Toggle Theme"></a></p>

    <div class="inner">
      

      
<!-- Menu -->
<nav id="menu">
  <span class="stack-info otp-version">Elixir 1.10.1 - Erlang/OTP 22.0 [erts-10.5.3]</span>
  <header class="major">
    <h2></h2>
    <p>The premier destination for learning and mastering Elixir</p>
  </header>
  <ul>
    <li>
      <a href="/" class=" up ">Home</a>
    </li>
  
    
    
    
    
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Basics</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/basics/basics/">1. Basics</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/collections/">2. Collections</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/enum/">3. Enum</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/pattern-matching/">4. Pattern Matching</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/control-structures/">5. Control Structures</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/functions/">6. Functions</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/pipe-operator/">7. Pipe Operator</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/modules/">8. Modules</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/mix/">9. Mix</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/sigils/">10. Sigils</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/documentation/">11. Documentation</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/testing/">12. Testing</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/comprehensions/">13. Comprehensions</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/strings/">14. Strings</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/date-time/">15. Date and Time</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/mix-tasks/">16. Custom Mix Tasks</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/iex-helpers/">17. IEx Helpers</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Advanced</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/advanced/erlang/">1. Erlang Interoperability</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/error-handling/">2. Error Handling</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/escripts/">3. Executables</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/concurrency/">4. Concurrency</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/otp-concurrency/">5. OTP Concurrency</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/otp-supervisors/">6. OTP Supervisors</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/otp-distribution/">7. OTP Distribution</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/metaprogramming/">8. Metaprogramming</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/umbrella-projects/">9. Umbrella Projects</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/typespec/">10. Specifications and types</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/behaviours/">11. Behaviours</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/gen-stage/">12. GenStage</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/protocols/">13. Protocols</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Ecto</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/ecto/basics/">1. Basics</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/ecto/changesets/">2. Changesets</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/ecto/associations/">3. Associations</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/ecto/querying/">4. Querying</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Specifics</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/specifics/plug/">1. Plug</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/eex/">2. Embedded Elixir (EEx)</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/ets/">3. Erlang Term Storage (ETS)</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/mnesia/">4. Mnesia</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/debugging/">5. Debugging</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/nerves/">6. Nerves</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Libraries</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/libraries/guardian/">1. Guardian (Basics)</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/poolboy/">2. Poolboy</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/benchee/">3. Benchee</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/bypass/">4. Bypass</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/distillery/">5. Distillery (Basics)</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/stream-data/">6. StreamData</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    <li>
      <a href="/blog/" class=" up active">Blog</a>
    </li>
    
    <li>
      <a href="/contributors/" class=" up ">Contributors</a>
    </li>
  </ul>
</nav>

      <!-- Footer -->
      <footer id="footer">
        <p class="copyright">&copy; 2021 <a target="_blank" rel="noopener" href="https://github.com/doomspork">Sean Callan</a> All rights reserved.</p>
      </footer>
    </div>
  </div>

		</div>
		<!-- Scripts -->

    <script async="" src="/assets/main-f8c201d2721dcb6d1d4f6acb0ebd2b2c192757ed29271f519513e4417e347611.js" type="text/javascript"></script>
		<!--[if lte IE 8]><script async="" src="/assets/ie/respond.min-8306093ccce666c01dab405fac0d16596a1d1cf38aa0ba919d4831261662cdbb.js" type="text/javascript"></script><script src="assets/js/ie/respond.min.js"></script><![endif]-->
	</body>
</html>
