<!DOCTYPE HTML>



<html lang="en">
	<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta name="description" content="">
  <meta name="author" content="Sean Callan">

  <meta property="og:url" content="http://localhost:4000/blog/live-view-with-channels/">
  <meta property="og:site_name" content="ElixirSchool">
  <meta property="og:title" content="">
  <meta property="og:locale" content="">
  <meta property="og:description" content="">
  <meta property="og:image" content="http://localhost:4000/assets/og_image-fad975b316dea5dc361d199bdfaa076006da49a0a3296f799aa7217b4c8b0cbe.jpg">
  
  

  <link rel="canonical" href="http://localhost:4000/blog/live-view-with-channels/">
  <link rel="apple-touch-icon" sizes="180x180" href="http://localhost:4000/assets/favicons/apple-touch-icon-06ad80501b5734bba0428ca0fc14fcbe45811a144914f7be78cdab3c3ea25458.png">
  <link rel="icon" type="image/png" sizes="32x32" href="http://localhost:4000/assets/favicons/favicon-32x32-6e7b9eca57d29d185a5184e844c1372ce9da0a71f373f89b80ff11f120b01678.png">
  <link rel="icon" type="image/png" sizes="16x16" href="http://localhost:4000/assets/favicons/favicon-16x16-789b56195138252cac40cf7f2425b6fcb4e71c3084abc8525781188781b958d3.png">
  <link rel="manifest" href="http://localhost:4000/manifest.json">
  <link rel="shortcut icon" href="http://localhost:4000/assets/favicons/favicon-8e1fdc2a44d6344b9871b3ecf53a803903891f82a602a3f59c65eda40f2b77b0.ico">
  <link rel="alternate" type="application/rss+xml" title="Elixir School" href="https://elixirschool.com/feed.xml" />
  <meta name="msapplication-config" content="http://localhost:4000/assets/favicons/browserconfig-e66282a6754e6899f9a53c6ebfe120749630242b741deb65f364abc297ccbc96.xml">
  <meta name="theme-color" content="#ffffff">

  
  
  <title>Using Channels with LiveView for Better UX &middot; Elixir School</title>
  <!-- CSS -->
  <!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
  <link rel="stylesheet" type="text/css" href="/assets/main-07a5a32c1a26652d2bb0e43b4c7ade37f20599a76cae3c1e871d3af53cff80b2.css">
  <!--[if lte IE 9]><link rel="stylesheet" type="text/css" href="/assets/ie9-0c07c3ea146a3dd5dce4effda97b3718824cab9c30149877c0e445edecfdee60.css"><![endif]-->
  <!--[if lte IE 8]><link rel="stylesheet" type="text/css" href="/assets/ie8-f0c85ce6ad95a6d33929cb969a44f41a5e96ecb22de55f55d0f3c83cfc0012fc.css"><![endif]-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
  <script type="text/javascript">
  !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.1.0";
  analytics.load("C0p07Sw9j7mZnycKDCgPOAyqJR5hhyoQ");
  analytics.page()
  }}();
  </script>
  <script type="text/javascript">
    if ("serviceWorker" in navigator) {
      if (!navigator.serviceWorker.controller) {
        navigator.serviceWorker.register("http://localhost:4000/serviceworker.js", {
          scope: "http://localhost:4000"
        })
        .then(reg => console.log("Service worker has been registered for scope: ", reg.scope))
        .catch(error => console.log("Service worker registration has failed: ", error));
      }
    }  
  </script>
</head>

	<body class="is-loading">
    <script type="text/javascript">
    var $theme = localStorage.getItem('theme');
    if ($theme === 'dark') document.body.classList.add("dark");
    </script>
		<!-- Wrapper -->
		<div id="wrapper">
			<!-- Main -->
			<div id="main">
				<div class="inner">
					<!-- Header -->
					<header id="header">
					  <a href="/" class="logo"><strong>Elixir School</strong> Blog</a>
					  <ul class="icons">
  
  <li><iframe src="https://ghbtns.com/github-btn.html?user=elixirschool&repo=elixirschool&type=star&count=true" height="20" title="GitHub Stars" width="93" style="vertical-align: sub;"></iframe></li>
  <li><a target="_blank" rel="noopener" title="RSS" href="https://elixirschool.com/feed.xml" class="icon fa-rss-square"><span class="label">RSS</span></a></li>
  <li><a target="_blank" rel="noopener" title="LinkedIn" href="https://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/blog/live-view-with-channels/&title=Using Channels with LiveView for Better UX&summary=description&source=http://localhost:4000" class="icon fa-linkedin"><span class="label">Linkedin</span></a></li>
  <li><a target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/intent/tweet?url=http://localhost:4000/blog/live-view-with-channels/&via=elixirschool&text=ElixirSchool: Using Channels with LiveView for Better UX&hashtags=learnelixir%2Celixirlang&" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
  <li><a target="_blank" rel="noopener" title="Facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/blog/live-view-with-channels/" class="icon fa-facebook"><span class="label">Facebook</span></a></li>
  <li><a target="_blank" rel="noopener" title="Pinterest" href="https://www.pinterest.com/pin/create/link/?url=http://localhost:4000/blog/live-view-with-channels/&media=http://localhost:4000/assets/og_image-fad975b316dea5dc361d199bdfaa076006da49a0a3296f799aa7217b4c8b0cbe.jpg&description=ElixirSchool: Using Channels with LiveView for Better UX" class="icon fa-pinterest"><span class="label">Pinterest</span></a></li>
  <li><a target="_blank" rel="noopener" title="VK" href="https://vk.com/share.php?url=http://localhost:4000/blog/live-view-with-channels/&title=ElixirSchool: Using Channels with LiveView for Better UX&description=Check out 'Using Channels with LiveView for Better UX' on ElixirSchool" class="icon fa-vk"><span class="label">VK</span></a></li>
  <li><a target="_blank" rel="noopener" title="Email" href="mailto:?to=&subject=ElixirSchool: Using Channels with LiveView for Better UX&body=Check out 'Using Channels with LiveView for Better UX' on ElixirSchool%0D%0A%0D%0Ahttp://localhost:4000/blog/live-view-with-channels/" class="icon fa-envelope"><span class="label">Email</span></a></li>
  <li><a title="Print" href="javascript:window.print()" class="icon fa-print"><span class="label">Print</span></a></li>
</ul>

					</header>
					

<section id="section-page">
  <header class="main">
    <h1 class="post-title">Using Channels with LiveView for Better UX</h1>
    <p><a href="/blog/years/2019/">04 Jun 2019</a> · by 

    <a href="https://thegreatcodeadventure.com" target="_blank" rel="nofollow noopener">Sophie DeBenedetto</a> in <a href="/blog/categories/general/">General</a></p>
  </header>
  <div class="content">
    <p>LiveView has given us the ability to implement flexible and responsive UX almost entirely with server-side code. But what happens when our need for a responsive UI surpasses what LiveView seemingly offers? When the demands of a particular feature have us reaching for JavaScript? It is possible to incorporate custom JS into the LiveView life cycle with the help of a custom LiveView channel and a Registry. Keep reading to see how we did it!</p>

<h2 id="the-problem">The Problem</h2>

<p>In a <a href="https://elixirschool.com/blog/live-view-with-presence/">recent post</a>, we built a straightforward chatting application backed by LiveView, PubSub and Presence. We implemented nearly all of the necessary features (live updates as users type in new messages, a list that keeps track of users in the chat room and who is typing!) with only 90 lines of LiveView code.</p>

<p>But then we ran into a blocker.</p>

<p>When new chat messages were appended to the chat window, they appeared <em>just</em> out of frame.</p>

<p><img src="/assets/chat-message-not-visible-636e5b63bfbbe5bc65bcdeb962b3f447c140f498877a16aa09392d4d568c0f8a.png" alt="chat message not visible" /></p>

<hr />

<p>The chat window needed to scroll down to accommodate and display the new message. This is easy enough to do with just one or two lines of JavaScript: grab the height of the chat window, and set the <code class="highlighter-rouge">scrollTop</code> accordingly.</p>

<p>If you’re familiar with Phoenix Channels, you might reach for something like this:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">channel</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">new_message</span><span class="dl">"</span><span class="p">,</span> <span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">targetNode</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByClassName</span><span class="p">(</span><span class="dl">"</span><span class="s2">messages</span><span class="dl">"</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nx">targetNode</span><span class="p">.</span><span class="nx">scrollTop</span> <span class="o">=</span> <span class="nx">targetNode</span><span class="p">.</span><span class="nx">scrollHeight</span>
<span class="p">})</span>
</code></pre></div></div>

<p>But wait! The LiveView client-side library only responds to <em>one</em> event from the LiveView process running on the server––the diff event. This event isn’t granular enough to tell us <em>what</em> changed on the page. It merely forces the appropriate portions of the page to re-render.</p>

<p>So, how can we get our LiveView to emit an event that our front-end <em>can</em> respond to in order to fire our <code class="highlighter-rouge">scrollTop</code>-adjusting JS?</p>

<h2 id="the-solution">The Solution</h2>

<p>We need to do a few things in order to get this working:</p>

<ul>
  <li>Extend the LiveView socket with a custom channel</li>
  <li>Teach our LiveView processes to send messages to that channel, so that the channel can push them to the client.</li>
</ul>

<p>It’s worth noting here that the responsibility of a custom LiveView channel should be narrowly scoped. LiveView can and should handle almost all of the updates to the LiveView template. That’s the beauty of LiveView! We don’t need to write a set of custom client-side functions for updating the page based on specific events like we’ve become used to doing when working with Phoenix Channels. However, when we need to trigger a client-side interaction, like our <code class="highlighter-rouge">scrollTop</code> adjustment, that the LiveView client isn’t capable of handling, we can reach for a custom channel.</p>

<p>Now that we have a basic understanding of the problem we’re trying to solve, and the tools we’ll use to solve it, let’s get started!</p>

<h2 id="the-process">The Process</h2>

<p>Before we start writing code, let’s walk through the desired code flow of this feature, one step at a time.</p>

<ol>
  <li>User visits <code class="highlighter-rouge">/chats/:id</code></li>
  <li>Controller mounts the live view and renders the static template</li>
  <li>Client connects to the Live View socket and joins a custom channel on this same socket</li>
</ol>

<p>Later…</p>

<ol>
  <li>User submits new chat message, sending an event to the live view</li>
  <li>The live view responds to the message by updating state, re-rendering the page and broadcasting the event to the other live view processes subscribing to that chat room topic</li>
  <li>The other live views receive the broadcast, update their own state and re-render the template</li>
  <li>The live views send the message to their “associated” channel (i.e. the channel joined on the live view’s socket)</li>
  <li>The channel receives the message and pushes it out to the front-end</li>
  <li>Front-end receives the message and responds by triggering our <code class="highlighter-rouge">scrollTop</code> adjustment JavaScript</li>
</ol>

<p>There is a lot of code to get through, so we’ve organized our approach into the following parts:</p>

<p>I. <a href="#-establishing-the-socket-and-channel">Establishing the Socket and Channel</a></p>

<p>II. <a href="#handling-events-in-the-liveview">Handling Events in the LiveView</a></p>

<p>III. <a href="#communicationg-from-the-liveview-to-the-channel">Communicating from the LiveView to the Channel</a></p>

<p>IV. <a href="#sending-messages-from-the-channel-to-the-front-end">Sending Messages From the Channel to the Front-End</a></p>

<h2 id="getting-started">Getting Started</h2>

<p>If you’d like to follow along with this tutorial, we recommend reading and completing the tutorial in our previous post <a href="https://elixirschool.com/blog/live-view-with-presence/">here</a> first. This will get your code into the correct starting state. You can also clone down the repo <a href="https://github.com/elixirschool/live-view-chat">here</a> to get the starting code. Otherwise, you can checkout the completed code <a href="https://github.com/elixirschool/live-view-chat/tree/live-view-channel-registry">here</a>.</p>

<h2 id="part-i-establishing-the-socket-and-channel">Part I: Establishing the Socket and Channel</h2>

<p>In order to guarantee that the live view process can send a message to the right channel at the right time, we need to have the live view share a socket with that channel. Let’s start by focusing on this portion of the code flow:</p>

<ol>
  <li>User visits <code class="highlighter-rouge">/chats/:id</code></li>
  <li>Controller mounts the live view and renders the static template</li>
  <li>Client connects to the Live View socket and joins the channel on this same socket</li>
</ol>

<p>Here’s a closer look at how this procedure works:</p>

<p><img src="/assets/live-view-mount-render-dbd2c5a4848829b86ea213a127a2cc4a8b06edc3e5167d28593fa9ad6d0a599a.png" alt="live view mounts and renders" /></p>

<hr />

<p><img src="/assets/live-view-socket-connect-a0fb82f53bf580475c831dee0f1cb9f5cb29497feb914924b33f4fc407470cce.png" alt="live view socket connects" /></p>

<hr />

<p><img src="/assets/live-view-channel-join-7a01d2bb0395bfdb55975eb16f71c7a93aeafcc9dd85d9e20a85510e1ae6e0ff.png" alt="live view channel joins" /></p>

<hr />

<p>Let’s dive in and write some code!</p>

<h3 id="extending-the-liveview-socket">Extending the LiveView Socket</h3>

<p>In order to define a custom channel that will share a socket with our LiveView process, we need to extend the LiveView socket that the LiveView library provides us. LiveView doesn’t (yet) provide a way for us to extend this module programmatically, so we’ll define our own socket with everything it needs to support our LiveView and our custom channel:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/phat_web/channels/live_socket.ex</span>
<span class="k">defmodule</span> <span class="no">PhatWeb</span><span class="o">.</span><span class="no">LiveSocket</span> <span class="k">do</span>
<span class="nv">@moduledoc</span> <span class="sd">"""
  The LiveView socket for Phoenix Endpoints.
  """</span>
  <span class="kn">use</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">Socket</span>

  <span class="k">defstruct</span> <span class="ss">id:</span> <span class="no">nil</span><span class="p">,</span>
            <span class="ss">endpoint:</span> <span class="no">nil</span><span class="p">,</span>
            <span class="ss">parent_pid:</span> <span class="no">nil</span><span class="p">,</span>
            <span class="ss">assigns:</span> <span class="p">%{},</span>
            <span class="ss">changed:</span> <span class="p">%{},</span>
            <span class="ss">fingerprints:</span> <span class="p">{</span><span class="no">nil</span><span class="p">,</span> <span class="p">%{}},</span>
            <span class="ss">private:</span> <span class="p">%{},</span>
            <span class="ss">stopped:</span> <span class="no">nil</span><span class="p">,</span>
            <span class="ss">connected?:</span> <span class="no">false</span>

  <span class="n">channel</span> <span class="s2">"lv:*"</span><span class="p">,</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">LiveView</span><span class="o">.</span><span class="no">Channel</span>
  <span class="n">channel</span> <span class="s2">"event_bus:*"</span><span class="p">,</span> <span class="no">PhatWeb</span><span class="o">.</span><span class="no">ChatChannel</span>

  <span class="nv">@doc</span> <span class="sd">"""
  Connects the Phoenix.Socket for a LiveView client.
  """</span>
  <span class="nv">@impl</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">Socket</span>
  <span class="k">def</span> <span class="n">connect</span><span class="p">(</span><span class="n">_params</span><span class="p">,</span> <span class="n">socket</span><span class="p">,</span> <span class="n">_connect_info</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">socket</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="nv">@doc</span> <span class="sd">"""
  Identifies the Phoenix.Socket for a LiveView client.
  """</span>
  <span class="nv">@impl</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">Socket</span>
  <span class="k">def</span> <span class="n">id</span><span class="p">(</span><span class="n">_socket</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="no">nil</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The only line we need to add in addition to what we’ve copied from the LiveView source code is the channel definition in which we map the topic, <code class="highlighter-rouge">"event_bus:*"</code> to our soon-to-be-defined custom channel.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">channel</span> <span class="s2">"event_bus:*"</span><span class="p">,</span> <span class="no">PhatWeb</span><span class="o">.</span><span class="no">ChatChannel</span>
</code></pre></div></div>

<p>Next we’ll tell our app’s <code class="highlighter-rouge">Endpoint</code> module to map the socket mounted at the <code class="highlighter-rouge">"/live"</code> endpoint to the socket we just defined:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/phat_web/endpoint.ex</span>
<span class="k">defmodule</span> <span class="no">PhatWeb</span><span class="o">.</span><span class="no">Endpoint</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">Endpoint</span><span class="p">,</span> <span class="ss">otp_app:</span> <span class="ss">:phat</span>
  <span class="c1"># socket "/live", Phoenix.LiveView.Socket</span>
  <span class="n">socket</span> <span class="s2">"/live"</span><span class="p">,</span> <span class="no">PhatWeb</span><span class="o">.</span><span class="no">LiveSocket</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="defining-the-custom-channel">Defining the Custom Channel</h3>

<p>Now we’re ready to define our <code class="highlighter-rouge">ChatChannel</code>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/phat_web/channels/chat_channel.ex</span>

<span class="k">defmodule</span> <span class="no">PhatWeb</span><span class="o">.</span><span class="no">ChatChannel</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">Channel</span>
  <span class="k">def</span> <span class="n">join</span><span class="p">(</span><span class="s2">"event_bus:"</span> <span class="o">&lt;&gt;</span> <span class="n">_chat_id</span><span class="p">,</span> <span class="n">_message</span><span class="p">,</span> <span class="n">socket</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">socket</span><span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="connecting-to-the-socket-and-joining-the-channel">Connecting to the Socket and Joining the Channel</h3>

<p>With our socket and our channel defined, we can tell the front-end client to join the channel after connecting to the LiveView socket:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// assets/js/app.js</span>
<span class="k">import</span> <span class="nx">LiveSocket</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">phoenix_live_view</span><span class="dl">"</span>

<span class="kd">let</span> <span class="nx">chatId</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">pathname</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">/</span><span class="dl">"</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="c1">// just a hack to get the chatId from the route, there are definitely better ways to do this!</span>

<span class="kd">const</span> <span class="nx">liveSocket</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LiveSocket</span><span class="p">(</span><span class="dl">"</span><span class="s2">/live</span><span class="dl">"</span><span class="p">)</span>
<span class="nx">liveSocket</span><span class="p">.</span><span class="nx">connect</span><span class="p">()</span>

<span class="kd">let</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">liveSocket</span><span class="p">.</span><span class="nx">channel</span><span class="p">(</span><span class="dl">"</span><span class="s2">event_bus:</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">chatId</span><span class="p">,</span> <span class="p">{})</span>
</code></pre></div></div>

<p>Now, when the page loads, we will:</p>

<ul>
  <li>Connect to and start the LiveView process running over the socket</li>
  <li>Join a channel over that <em>same</em> socket</li>
</ul>

<p>Later, we can write some code on the front-end to respond to a specific event by changing the chat box’s scroll height:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">channel</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">new_message</span><span class="dl">"</span><span class="p">,</span> <span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">targetNode</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByClassName</span><span class="p">(</span><span class="dl">"</span><span class="s2">messages</span><span class="dl">"</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nx">targetNode</span><span class="p">.</span><span class="nx">scrollTop</span> <span class="o">=</span> <span class="nx">targetNode</span><span class="p">.</span><span class="nx">scrollHeight</span>
<span class="p">})</span>
</code></pre></div></div>

<p>So, how can we get our channel to send the <code class="highlighter-rouge">"new_message"</code> event to the front-end? Let’s find out!</p>

<h2 id="part-ii-handling-events-in-the-liveview">Part II: Handling Events in the LiveView</h2>

<p>In this section, we’ll dive into the following portion of the process:</p>

<ol>
  <li>User submits a new chat message, sending an event to the live view; The live view updates its state and re-renders the template</li>
  <li>The live view broadcasts the event to the other live view processes subscribing to that chat room topic which then update their own state and re-render their templates</li>
  <li>The live views send a message <em>to themselves</em>, instructing them to in turn send a message to their “associated” channel (i.e. the channel joined on the live view’s socket). This ensures that the live view will finish re-rendering <em>before</em> telling the channel to push a message to the front-end.</li>
</ol>

<p>Here’s a closer look at this flow:</p>

<p><img src="/assets/live-view-handle-event-07e9afbb4dcefb73c975b71944bedfc5291cede4f09e4e237660a9653a465161.png" alt="live view handles event" /></p>

<hr />

<p><img src="/assets/live-view-broadcasts-event-531b91250f86cd558d77699b277d586b5dd6ff0b103edb29cf20f99f35d8261c.png" alt="live view broadcasts event" /></p>

<hr />

<p><img src="/assets/live-view-send-self-030345f207cfe93066044d68ef2b64570f67634f7f62617580d3d0ab420dd992.png" alt="live view sends message to self" /></p>

<hr />

<h3 id="receiving-events-in-the-liveview">Receiving Events in the LiveView</h3>

<p>When a user submits a new message via the chat form, it will send the <code class="highlighter-rouge">"new_message"</code> event to the LiveView process, over the socket. Our live view process already responds to this message by:</p>

<ul>
  <li>Updating its own state and re-rendering the template to display the new message.</li>
  <li>Broadcasting the message to the other running live view processes subscribed to the same topic so that everyone gets the new message and subsequent re-render.</li>
</ul>

<p>To get a refresher on how this works, check out our earlier post <a href="https://elixirschool.com/blog/live-view-with-presence/">here</a>. In this post, we’ll just take a brief look at that code:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/phat_web/live/chat_live_view.ex</span>

<span class="c1"># this function fires when we receive the "new_message" event from the front-end</span>
<span class="k">def</span> <span class="n">handle_event</span><span class="p">(</span><span class="s2">"new_message"</span><span class="p">,</span> <span class="p">%{</span><span class="s2">"message"</span> <span class="o">=&gt;</span> <span class="n">message_params</span><span class="p">},</span> <span class="n">socket</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">chat</span> <span class="o">=</span> <span class="no">Chats</span><span class="o">.</span><span class="n">create_message</span><span class="p">(</span><span class="n">message_params</span><span class="p">)</span>
  <span class="no">PhatWeb</span><span class="o">.</span><span class="no">Endpoint</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">topic</span><span class="p">(</span><span class="n">chat</span><span class="o">.</span><span class="n">id</span><span class="p">),</span> <span class="s2">"new_message"</span><span class="p">,</span> <span class="p">%{</span><span class="ss">chat:</span> <span class="n">chat</span><span class="p">})</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">assign</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="ss">chat:</span> <span class="n">chat</span><span class="p">,</span> <span class="ss">message:</span> <span class="no">Chats</span><span class="o">.</span><span class="n">change_message</span><span class="p">())}</span>
<span class="k">end</span>

<span class="c1"># this function fires when all of the subscribing live view processes receive the broadcast from above</span>
<span class="k">def</span> <span class="n">handle_info</span><span class="p">(%{</span><span class="ss">event:</span> <span class="s2">"new_message"</span><span class="p">,</span> <span class="ss">payload:</span> <span class="n">state</span><span class="p">},</span> <span class="n">socket</span><span class="p">)</span> <span class="k">do</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">assign</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">state</span><span class="p">)}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Its important to note that the live view is broadcasting the message to <em>all</em> of the LiveView processes subscribed to the chat room’s topic, including itself. However, LiveView is smart enough not to re-render a page for which there are no diffs, so this isn’t an expensive operation.</p>

<h3 id="sending-messages-from-the-liveview-to-the-channel">Sending Messages from the LiveView to the Channel</h3>

<p>We need to ensure that the page has a chance to re-render before we have the channel send the message to the front-end. Otherwise the JavaScript function to adjust <code class="highlighter-rouge">scrollTop</code> might run before the new message is present on the page, thereby failing to actually make an adjustment to the chat window.</p>

<p><em>After</em> this <code class="highlighter-rouge">handle_info/2</code> function returns is the point at which we can be sure all LiveView templates are re-rendered:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">handle_info</span><span class="p">(%{</span><span class="ss">event:</span> <span class="s2">"new_message"</span><span class="p">,</span> <span class="ss">payload:</span> <span class="n">state</span><span class="p">},</span> <span class="n">socket</span><span class="p">)</span> <span class="k">do</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">assign</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">state</span><span class="p">)}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So, how can we make sure each LiveView process handling this message will only send a message to the channel <em>after</em> this function finishes working? We can use <code class="highlighter-rouge">send/2</code> to have the live view send a message to itself! Since a process can only do one thing at a time, the live view process will finish the the current work in the <code class="highlighter-rouge">handle_info/2</code>  processing the <code class="highlighter-rouge">"new_message"</code> event <em>before</em> acting on the message it receives from itself.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">handle_info</span><span class="p">(%{</span><span class="ss">event:</span> <span class="s2">"new_message"</span><span class="p">,</span> <span class="ss">payload:</span> <span class="n">state</span><span class="p">},</span> <span class="n">socket</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">send</span><span class="p">(</span><span class="n">self</span><span class="p">(),</span> <span class="p">{</span><span class="ss">:send_to_event_bus</span><span class="p">,</span> <span class="s2">"new_message"</span><span class="p">})</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">assign</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">state</span><span class="p">)}</span>
<span class="k">end</span>

<span class="k">def</span> <span class="n">handle_info</span><span class="p">({</span><span class="ss">:send_to_event_bus</span><span class="p">,</span> <span class="n">msg</span><span class="p">},</span> <span class="n">socket</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># send a message to the channel here!</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">socket</span><span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now we’ve captured the moment in time at which to send a message from the LiveView process to the Channel process. But wait! How can we send a message to a process whose PID we don’t know? The LiveView process, in its current form, doesn’t know about the channel process with which it shares a socket. In order to fix this, we’ll need to leverage a Registry.</p>

<h2 id="part-iii-communicating-from-the-liveview-to-the-channel">Part III: Communicating from the LiveView to the Channel</h2>

<p>In this section, we’ll register our channel process so that the live view can look up and send a message to the appropriate channel PID. Then, we’ll teach the live view how to perform this lookup and send a message to the right channel PID.</p>

<p>Here’s the code flow we’re aiming for:</p>

<ol>
  <li>The LiveView is mounted from the controller and stores a unique identifier of a “session UUID” in its own state; it renders the template with a hidden element that contains the session UUID encoded in a <code class="highlighter-rouge">Phoenix.Token</code></li>
  <li>The channel’s socket is connected with this token; the socket stores it in state.</li>
  <li>The channel is joined; it takes the session UUID from its socket’s state and registers its PID under a key of that UUID.</li>
</ol>

<p><img src="/assets/live-view-mount-session-uuid-7d42d71da5cbbb018ee7355b6e886f08f7d931bb36993ad71a1544a5612061de.png" alt="live view mounts with session uuid" /></p>

<hr />

<p><img src="/assets/live-view-connect-channel-00f63e49d325e2f1695e04e724c104d798715cc133b090bf28b81e6eb8752f2a.png" alt="live view channel connects" /></p>

<hr />

<p><img src="/assets/live-view-channel-register-835188bac138761e9b6311391f9258993d665c93af43174f76c14eccf2d0d5c0.png" alt="live view channel register" /></p>

<hr />

<p>Later…</p>

<ol>
  <li>When the user submits a new chat message, the LiveView processes that received the message broadcast will look up the channel PID under the session UUID in the registry</li>
  <li>Each live view will then send the message to the PID they looked up</li>
</ol>

<p><img src="/assets/live-view-lookup-send-to-channel-ef04590f8407467e90778798ff76ee7755f595561355d9b83ec960ee12e42bd7.png" alt="live view looks up channel" /></p>

<hr />

<h3 id="defining-the-channel-registry">Defining the Channel Registry</h3>

<p>We’ll use a process registry, implemented with Elixir’s native <a href="https://hexdocs.pm/elixir/Registry.html">Registry</a> module, to keep track of the channel PID so that the LiveView can look up its associated channel in order to send it a message.</p>

<p><em>Its important to note that Elixir’s Registry module isn’t distribution friendly––if you look up a given PID created on one server on a totally different server, there’s no guarantee that it will refer to the same process. But! Since our channel shares a socket with the LiveView process, it is guaranteed that the live view and the channel are running on the same server.</em></p>

<p>We’ll tell Elixir’s Registry supervisor to start supervising a named registry called <code class="highlighter-rouge">SessionRegistry</code> when our app starts up:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># application.ex</span>

<span class="k">def</span> <span class="n">start</span><span class="p">(</span><span class="n">_type</span><span class="p">,</span> <span class="n">_args</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">[</span>
      <span class="no">Phat</span><span class="o">.</span><span class="no">Repo</span><span class="p">,</span>
      <span class="no">PhatWeb</span><span class="o">.</span><span class="no">Endpoint</span><span class="p">,</span>
      <span class="no">PhatWeb</span><span class="o">.</span><span class="no">Presence</span><span class="p">,</span>
      <span class="p">{</span><span class="no">Registry</span><span class="p">,</span> <span class="p">[</span><span class="ss">keys:</span> <span class="ss">:unique</span><span class="p">,</span> <span class="ss">name:</span> <span class="no">Registry</span><span class="o">.</span><span class="no">SessionRegistry</span><span class="p">]}</span>
    <span class="p">]</span>

    <span class="n">opts</span> <span class="o">=</span> <span class="p">[</span><span class="ss">strategy:</span> <span class="ss">:one_for_one</span><span class="p">,</span> <span class="ss">name:</span> <span class="no">Phat</span><span class="o">.</span><span class="no">Supervisor</span><span class="p">]</span>
    <span class="no">Supervisor</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>We want to register our channel PID when the channel is joined. But we need to store the PID under a unique key that the live view can use to look it up by later. So, we need to create such an identifier and find a way to make it available to both the live view and the channel.</p>

<h3 id="sharing-the-session-uuid">Sharing the Session UUID</h3>

<p>When the LiveView first mounts via the controller, we’ll create a unique identifier––a session UUID––to store in the live view’s state:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/phat_web/controllers/chat_controller.ex</span>

<span class="k">def</span> <span class="n">show</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="p">%{</span><span class="s2">"id"</span> <span class="o">=&gt;</span> <span class="n">chat_id</span><span class="p">})</span> <span class="k">do</span>
  <span class="n">chat</span> <span class="o">=</span> <span class="no">Chats</span><span class="o">.</span><span class="n">get_chat</span><span class="p">(</span><span class="n">chat_id</span><span class="p">)</span>
  <span class="n">session_uuid</span> <span class="o">=</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">UUID</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
  <span class="no">LiveView</span><span class="o">.</span><span class="no">Controller</span><span class="o">.</span><span class="n">live_render</span><span class="p">(</span>
    <span class="n">conn</span><span class="p">,</span>
    <span class="no">ChatLiveView</span><span class="p">,</span>
    <span class="ss">session:</span> <span class="p">%{</span>
      <span class="ss">chat:</span> <span class="n">chat</span><span class="p">,</span>
      <span class="ss">current_user:</span> <span class="n">conn</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">current_user</span><span class="p">,</span>
      <span class="ss">session_uuid:</span> <span class="n">session_uuid</span>
    <span class="p">}</span>
  <span class="p">)</span>
<span class="k">end</span>

<span class="c1"># lib/phat_web/live/chat_live_view.ex</span>

<span class="k">def</span> <span class="n">mount</span><span class="p">(%{</span><span class="ss">chat:</span> <span class="n">chat</span><span class="p">,</span> <span class="ss">current_user:</span> <span class="n">current_user</span><span class="p">,</span> <span class="ss">session_uuid:</span> <span class="n">session_uuid</span><span class="p">},</span> <span class="n">socket</span><span class="p">)</span> <span class="k">do</span>
  <span class="o">...</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">assign</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span>
    <span class="ss">chat:</span> <span class="n">chat</span><span class="p">,</span>
    <span class="ss">message:</span> <span class="no">Chats</span><span class="o">.</span><span class="n">change_message</span><span class="p">(),</span>
    <span class="ss">current_user:</span> <span class="n">current_user</span><span class="p">,</span>
    <span class="ss">users:</span> <span class="no">Presence</span><span class="o">.</span><span class="n">list_presences</span><span class="p">(</span><span class="n">topic</span><span class="p">(</span><span class="n">chat</span><span class="o">.</span><span class="n">id</span><span class="p">)),</span>
    <span class="ss">username_colors:</span> <span class="n">username_colors</span><span class="p">(</span><span class="n">chat</span><span class="p">),</span>
    <span class="ss">session_uuid:</span> <span class="n">session_uuid</span><span class="p">,</span>
    <span class="ss">token:</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">Token</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="no">PhatWeb</span><span class="o">.</span><span class="no">Endpoint</span><span class="p">,</span> <span class="s2">"user salt"</span><span class="p">,</span> <span class="n">session_uuid</span><span class="p">)</span>
  <span class="p">)}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In the <code class="highlighter-rouge">mount/2</code> function of our live view, we store the session UUID in the socket’s state so that we can use it to look up the channel PID later. We also encode the session UUID into a signed <code class="highlighter-rouge">Phoenix.Token</code> so that we can put it on the page and use it when we join the channel from the client-side.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/phat_web/templates/chat/show.html.leex</span>

<span class="o">&lt;%=</span> <span class="n">tag</span> <span class="ss">:meta</span><span class="p">,</span> <span class="ss">name:</span> <span class="s2">"channel_token"</span><span class="p">,</span> <span class="ss">content:</span> <span class="nv">@token</span> <span class="p">%</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>Let’s take a look at how we will give our channel access to this token.</p>

<p>When we send the socket connection request from the browser, we hit the <code class="highlighter-rouge">connect/3</code> function of our extended Live View socket, <code class="highlighter-rouge">PhatWeb.LiveSocket</code>. At this time, we <em>don’t</em> have access to the Live View process’s representation of the socket, but we <em>do</em> have access to the channel’s representation of the socket.</p>

<p>We need to give the channel awareness of the session UUID. So, we’ll include the signed token from the page in the socket connection request and use <code class="highlighter-rouge">connect/3</code> to store the session UUID in the channel’s socket state.</p>

<p>We’ll include the token in our socket connection request on the front-end:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// assets/js/app.js</span>
<span class="kd">const</span> <span class="nx">channelToken</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">meta</span><span class="dl">'</span><span class="p">)[</span><span class="mi">3</span><span class="p">].</span><span class="nx">content</span>
<span class="kd">const</span> <span class="nx">liveSocket</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LiveSocket</span><span class="p">(</span><span class="dl">"</span><span class="s2">/live</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span><span class="na">params</span><span class="p">:</span> <span class="p">{</span><span class="na">channel_token</span><span class="p">:</span> <span class="nx">channelToken</span><span class="p">}})</span>
<span class="nx">liveSocket</span><span class="p">.</span><span class="nx">connect</span><span class="p">()</span>
</code></pre></div></div>

<p>And we’ll have the <code class="highlighter-rouge">PhatWeb.LiveSocket.connect/3</code> function verify the token, extract the session UUID and store it in the channel socket’s state:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/phat_web/channels/live_socket.ex</span>

<span class="k">def</span> <span class="n">connect</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">socket</span><span class="p">,</span> <span class="n">_connect_info</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">case</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">Token</span><span class="o">.</span><span class="n">verify</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="s2">"user salt"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">"channel_token"</span><span class="p">],</span> <span class="ss">max_age:</span> <span class="mi">86400</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">session_uuid</span><span class="p">}</span> <span class="o">-&gt;</span>
      <span class="n">socket</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="ss">:session_uuid</span><span class="p">,</span> <span class="n">session_uuid</span><span class="p">)</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">socket</span><span class="p">}</span>

    <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">_</span><span class="p">}</span> <span class="o">-&gt;</span>
      <span class="ss">:error</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="registering-the-channel-process">Registering The Channel Process</h3>

<p>Now, when we join the channel, we can look up the <code class="highlighter-rouge">:session_uuid</code> in the channel socket’s state and use it to register the channel’s PID in the <code class="highlighter-rouge">SessionRegistry</code> under a key of this UUID:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/phat_web/channels/chat_channel.ex</span>

<span class="k">defmodule</span> <span class="no">PhatWeb</span><span class="o">.</span><span class="no">ChatChannel</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">Channel</span>

  <span class="k">def</span> <span class="n">join</span><span class="p">(</span><span class="s2">"event_bus:"</span> <span class="o">&lt;&gt;</span> <span class="n">_chat_id</span><span class="p">,</span> <span class="n">_message</span><span class="p">,</span> <span class="n">socket</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">Registry</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="no">Registry</span><span class="o">.</span><span class="no">SessionRegistry</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">session_uuid</span><span class="p">,</span> <span class="n">self</span><span class="p">())</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">socket</span><span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now our registry is up and running, and we’re registering a given channel PID under a unique identifier (session UUID) that live view with which the channel shares a socket connection is aware of.</p>

<p>We’re ready to have the live view send a message to its channel!</p>

<h3 id="sending-messages-to-the-channel">Sending Messages to the Channel</h3>

<p>Let’s recap the “new chat message” process so far:</p>

<ul>
  <li>A user submits the “new message” form and sends a <code class="highlighter-rouge">"new_message"</code> event to the live view</li>
  <li>The live view responds to this event by updating its own socket’s state, re-rendering <em>and</em> broadcasting the <code class="highlighter-rouge">"new_message"</code> event to all the live view processes subscribing to the topic for this chat room, i.e. the processes that represent the other users in the chat room.</li>
  <li>The live view processes receive this message broadcast and respond to it by updating their own state and re-rendering. They also <code class="highlighter-rouge">send</code> a message to themselves that they will process once they finish re-rendering.</li>
  <li>The live view processes responds to the message they sent themselves, telling themselves to send a message to the channel with which they share a socket.</li>
</ul>

<p>Now our live views have what they need to look up their associated channel. They are storing the <em>same</em> session UUID in state that the channel used to register its PID in the <code class="highlighter-rouge">SessionRegistry</code>. So, our live views can look up the channel PID and send a message to that PID.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/phat_web/live/chat_live_view.ex</span>

<span class="c1"># handle the broadcast of the "new_message" event from the live view that received it from the user</span>
<span class="k">def</span> <span class="n">handle_info</span><span class="p">(%{</span><span class="ss">event:</span> <span class="s2">"new_message"</span><span class="p">,</span> <span class="ss">payload:</span> <span class="n">state</span><span class="p">},</span> <span class="n">socket</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">send</span><span class="p">(</span><span class="n">self</span><span class="p">(),</span> <span class="p">{</span><span class="ss">:send_to_event_bus</span><span class="p">,</span> <span class="s2">"new_message"</span><span class="p">})</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">assign</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">state</span><span class="p">)}</span>
<span class="k">end</span>

<span class="c1"># handle the message sent above, after re-rendering the template</span>
<span class="k">def</span> <span class="n">handle_info</span><span class="p">({</span><span class="ss">:send_to_event_bus</span><span class="p">,</span> <span class="n">msg</span><span class="p">},</span> <span class="n">socket</span> <span class="o">=</span> <span class="p">%{</span><span class="ss">assigns:</span> <span class="p">%{</span><span class="ss">session_uuid:</span> <span class="n">session_uuid</span><span class="p">}})</span> <span class="k">do</span>
  <span class="p">[{</span><span class="n">_pid</span><span class="p">,</span> <span class="n">channel_pid</span><span class="p">}]</span> <span class="o">=</span> <span class="no">Registry</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="no">Registry</span><span class="o">.</span><span class="no">SessionRegistry</span><span class="p">,</span> <span class="n">session_uuid</span><span class="p">)</span>
  <span class="n">send</span><span class="p">(</span><span class="n">channel_pid</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">socket</span><span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Each live view process shares a session UUID with the channel that was joined on its socket. In this sense, each live view has an “associated” channel. By registering the channel PID under this session UUID, the given live view can look up its associated channel’s PID and send a message to that channel and that channel only.</p>

<p>Next up, we need to teach our channel to respond to this message.</p>

<h2 id="part-iv-sending-messages-from-the-channel-to-the-front-end">Part IV: Sending Messages from the Channel to the Front End</h2>

<p>In this section, we’ll focus on the following portion of our process:</p>

<ol>
  <li>The channel receives the message from the live view and pushes it out to the front-end</li>
  <li>The front-end receives the message and responds by triggering our <code class="highlighter-rouge">scrollTop</code> adjustment JavaScript</li>
</ol>

<p>Here’s a closer look:</p>

<p><img src="/assets/live-view-channel-push-ffbfdb98df546141488683d3b39582473ccfa0ec12342ee270a8f9c3180eba5b.png" alt="live view channel push" /></p>

<hr />
<p><img src="/assets/live-view-front-end-update-d69dab82dbaebc110265742953633bc00006bb7ed4a9c0c202546dea4002f4ee.png" alt="live view front end update" /></p>

<hr />

<h3 id="receiving-messages-in-the-channel">Receiving Messages in the Channel</h3>

<p>We need to define a <code class="highlighter-rouge">handle_info/</code> in the <code class="highlighter-rouge">ChatChannel</code> that knows how to respond to <code class="highlighter-rouge">"new_message"</code> messages by pushing them down the socket to the front-end.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># channel</span>
<span class="k">def</span> <span class="n">handle_info</span><span class="p">(</span><span class="s2">"new_message"</span><span class="p">,</span> <span class="n">socket</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">push</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="p">%{})</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">socket</span><span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="responding-to-messages-on-the-front-end">Responding to Messages on the Front-End</h3>

<p>On the front-end, our channel JS is ready and waiting to fire:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// assets/js/app.js</span>

<span class="nx">channel</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">new_message</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">targetNode</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByClassName</span><span class="p">(</span><span class="dl">"</span><span class="s2">messages</span><span class="dl">"</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nx">targetNode</span><span class="p">.</span><span class="nx">scrollTop</span> <span class="o">=</span> <span class="nx">targetNode</span><span class="p">.</span><span class="nx">scrollHeight</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Now, right after the page re-renders, the channel will receive the <code class="highlighter-rouge">"new_message"</code> message and push it to the client which is listening for just this event. The client reacts by firing our <code class="highlighter-rouge">scrollTop</code> adjustment JS and the user experiences a responsive UI––a chat window that automatically and seamlessly scrolls down to accommodate new messages in real-time.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We’ve seen that a seeming “limit” of LiveView can be surpassed by incorporating available Phoenix real-time tools––in this case Phoenix Channels. The work in this post raises the question: “What <em>should</em> LiveView be capable of?” Is the extension of LiveView with a custom Phoenix Channel a violation of the “purpose” of LiveView? Does such a use-case mean we should eschew LiveView in favor of Channels?</p>

<p>I think there are still distinctive advantages to using LiveView to back a feature like our chat app. Almost all of the chat functionality is handled in less than 100 lines of LiveView code. This is as opposed to all of the Channel back and front-end code that you would otherwise write. So, I would like to see LiveView become <em>more</em> extensible and configurable, making it easier to incorporate custom channels out-of-the-box.</p>

    

    <blockquote class="edit-lesson">
      Caught a mistake or want to contribute to the article?
      <a href="https://github.com/elixirschool/elixirschool/edit/master/_posts/2019-06-04-live-view-with-channels.md" target="_blank" rel="noopener">
        Edit this page on GitHub!
      </a>
    </blockquote>
  </div>
</section>
<section class="section-prevnext">
  <div class="row">
    <div class="6u 12u$(small)">
      
        <h4 class="title is-7 has-text-grey-light">Previous article</h4>
        <a class="button special fit" href="http://localhost:4000/blog/live-view-with-presence/" title="Tracking Users in a Chat App with LiveView, PubSub Presence" rel="prev">&laquo; Tracking Users in a Chat App with LiveView, Pub...</a>
      
    </div>
    <div class="6u 12u$(small)">
      
        <h4>Next article</h4>
        <a class="button special fit" href="http://localhost:4000/blog/elixir-conf-eu-2019-review/" title="Reviewing Elixir Conf EU 2019" rel="next">Reviewing Elixir Conf EU 2019 &raquo;</a>
      
    </div>
  </div>
</section>

<section>

    
  
    <div class="row profile">
  <div class="1u 2u(medium) 12u$(small)"><img src="https://github.com/SophieDeBenedetto.png" alt="" style="max-width: 60px;"></div>
  <div class="11u 10u(medium) 12u$(small)">
    <h2>
    
      <a href="https://github.com/SophieDeBenedetto">Sophie DeBenedetto</a>
    
    </h2>
    <p class="content">Sophie is an engineer and teacher at The Flatiron School. She loves teaching and learning and finding the Elixir School community felt like the perfect fit!</p>
    <ul class="icons">
      
      <li><a href="https://thegreatcodeadventure.com" class="icon fa-globe"><span class="label">Homepage</span></a></li>
      
      
      <li><a href="https://twitter.com/sm_debenedetto" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
      
      <li><a href="https://github.com/SophieDeBenedetto" class="icon fa-github"><span class="label">Github</span></a></li>
    </ul>
  </div>
</div>

  
</section>

				</div>
			</div>
			<!-- Sidebar -->
  <div id="sidebar">
    <p class="toggle-theme-wrapper"><a rel="noopener" href="#toggle-theme" class="toggle-theme icon fas fa-circle-o" alt="Toggle Theme" title="Toggle Theme"></a></p>

    <div class="inner">
      

      
<!-- Menu -->
<nav id="menu">
  <span class="stack-info otp-version">Elixir 1.10.1 - Erlang/OTP 22.0 [erts-10.5.3]</span>
  <header class="major">
    <h2></h2>
    <p>The premier destination for learning and mastering Elixir</p>
  </header>
  <ul>
    <li>
      <a href="/" class=" up ">Home</a>
    </li>
  
    
    
    
    
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Basics</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/basics/basics/">1. Basics</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/collections/">2. Collections</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/enum/">3. Enum</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/pattern-matching/">4. Pattern Matching</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/control-structures/">5. Control Structures</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/functions/">6. Functions</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/pipe-operator/">7. Pipe Operator</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/modules/">8. Modules</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/mix/">9. Mix</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/sigils/">10. Sigils</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/documentation/">11. Documentation</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/testing/">12. Testing</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/comprehensions/">13. Comprehensions</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/strings/">14. Strings</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/date-time/">15. Date and Time</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/mix-tasks/">16. Custom Mix Tasks</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/iex-helpers/">17. IEx Helpers</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Advanced</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/advanced/erlang/">1. Erlang Interoperability</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/error-handling/">2. Error Handling</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/escripts/">3. Executables</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/concurrency/">4. Concurrency</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/otp-concurrency/">5. OTP Concurrency</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/otp-supervisors/">6. OTP Supervisors</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/otp-distribution/">7. OTP Distribution</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/metaprogramming/">8. Metaprogramming</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/umbrella-projects/">9. Umbrella Projects</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/typespec/">10. Specifications and types</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/behaviours/">11. Behaviours</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/gen-stage/">12. GenStage</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/protocols/">13. Protocols</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Ecto</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/ecto/basics/">1. Basics</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/ecto/changesets/">2. Changesets</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/ecto/associations/">3. Associations</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/ecto/querying/">4. Querying</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Specifics</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/specifics/plug/">1. Plug</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/eex/">2. Embedded Elixir (EEx)</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/ets/">3. Erlang Term Storage (ETS)</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/mnesia/">4. Mnesia</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/debugging/">5. Debugging</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/nerves/">6. Nerves</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Libraries</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/libraries/guardian/">1. Guardian (Basics)</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/poolboy/">2. Poolboy</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/benchee/">3. Benchee</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/bypass/">4. Bypass</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/distillery/">5. Distillery (Basics)</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/stream-data/">6. StreamData</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    <li>
      <a href="/blog/" class=" up active">Blog</a>
    </li>
    
    <li>
      <a href="/contributors/" class=" up ">Contributors</a>
    </li>
  </ul>
</nav>

      <!-- Footer -->
      <footer id="footer">
        <p class="copyright">&copy; 2021 <a target="_blank" rel="noopener" href="https://github.com/doomspork">Sean Callan</a> All rights reserved.</p>
      </footer>
    </div>
  </div>

		</div>
		<!-- Scripts -->

    <script async="" src="/assets/main-f8c201d2721dcb6d1d4f6acb0ebd2b2c192757ed29271f519513e4417e347611.js" type="text/javascript"></script>
		<!--[if lte IE 8]><script async="" src="/assets/ie/respond.min-8306093ccce666c01dab405fac0d16596a1d1cf38aa0ba919d4831261662cdbb.js" type="text/javascript"></script><script src="assets/js/ie/respond.min.js"></script><![endif]-->
	</body>
</html>
