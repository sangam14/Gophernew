<!DOCTYPE HTML>



<html lang="en">
	<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta name="description" content="">
  <meta name="author" content="Sean Callan">

  <meta property="og:url" content="http://localhost:4000/blog/instrumenting_phoenix_with_telemetry_part_three/">
  <meta property="og:site_name" content="ElixirSchool">
  <meta property="og:title" content="">
  <meta property="og:locale" content="">
  <meta property="og:description" content="">
  <meta property="og:image" content="http://localhost:4000/assets/og_image-fad975b316dea5dc361d199bdfaa076006da49a0a3296f799aa7217b4c8b0cbe.jpg">
  
  

  <link rel="canonical" href="http://localhost:4000/blog/instrumenting_phoenix_with_telemetry_part_three/">
  <link rel="apple-touch-icon" sizes="180x180" href="http://localhost:4000/assets/favicons/apple-touch-icon-06ad80501b5734bba0428ca0fc14fcbe45811a144914f7be78cdab3c3ea25458.png">
  <link rel="icon" type="image/png" sizes="32x32" href="http://localhost:4000/assets/favicons/favicon-32x32-6e7b9eca57d29d185a5184e844c1372ce9da0a71f373f89b80ff11f120b01678.png">
  <link rel="icon" type="image/png" sizes="16x16" href="http://localhost:4000/assets/favicons/favicon-16x16-789b56195138252cac40cf7f2425b6fcb4e71c3084abc8525781188781b958d3.png">
  <link rel="manifest" href="http://localhost:4000/manifest.json">
  <link rel="shortcut icon" href="http://localhost:4000/assets/favicons/favicon-8e1fdc2a44d6344b9871b3ecf53a803903891f82a602a3f59c65eda40f2b77b0.ico">
  <link rel="alternate" type="application/rss+xml" title="Elixir School" href="https://elixirschool.com/feed.xml" />
  <meta name="msapplication-config" content="http://localhost:4000/assets/favicons/browserconfig-e66282a6754e6899f9a53c6ebfe120749630242b741deb65f364abc297ccbc96.xml">
  <meta name="theme-color" content="#ffffff">

  
  
  <title>Instrumenting Phoenix with Telemetry Part III: Phoenix + Ecto Telemetry Events &middot; Elixir School</title>
  <!-- CSS -->
  <!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
  <link rel="stylesheet" type="text/css" href="/assets/main-07a5a32c1a26652d2bb0e43b4c7ade37f20599a76cae3c1e871d3af53cff80b2.css">
  <!--[if lte IE 9]><link rel="stylesheet" type="text/css" href="/assets/ie9-0c07c3ea146a3dd5dce4effda97b3718824cab9c30149877c0e445edecfdee60.css"><![endif]-->
  <!--[if lte IE 8]><link rel="stylesheet" type="text/css" href="/assets/ie8-f0c85ce6ad95a6d33929cb969a44f41a5e96ecb22de55f55d0f3c83cfc0012fc.css"><![endif]-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
  <script type="text/javascript">
  !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.1.0";
  analytics.load("C0p07Sw9j7mZnycKDCgPOAyqJR5hhyoQ");
  analytics.page()
  }}();
  </script>
  <script type="text/javascript">
    if ("serviceWorker" in navigator) {
      if (!navigator.serviceWorker.controller) {
        navigator.serviceWorker.register("http://localhost:4000/serviceworker.js", {
          scope: "http://localhost:4000"
        })
        .then(reg => console.log("Service worker has been registered for scope: ", reg.scope))
        .catch(error => console.log("Service worker registration has failed: ", error));
      }
    }  
  </script>
</head>

	<body class="is-loading">
    <script type="text/javascript">
    var $theme = localStorage.getItem('theme');
    if ($theme === 'dark') document.body.classList.add("dark");
    </script>
		<!-- Wrapper -->
		<div id="wrapper">
			<!-- Main -->
			<div id="main">
				<div class="inner">
					<!-- Header -->
					<header id="header">
					  <a href="/" class="logo"><strong>Elixir School</strong> Blog</a>
					  <ul class="icons">
  
  <li><iframe src="https://ghbtns.com/github-btn.html?user=elixirschool&repo=elixirschool&type=star&count=true" height="20" title="GitHub Stars" width="93" style="vertical-align: sub;"></iframe></li>
  <li><a target="_blank" rel="noopener" title="RSS" href="https://elixirschool.com/feed.xml" class="icon fa-rss-square"><span class="label">RSS</span></a></li>
  <li><a target="_blank" rel="noopener" title="LinkedIn" href="https://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/blog/instrumenting_phoenix_with_telemetry_part_three/&title=Instrumenting Phoenix with Telemetry Part III: Phoenix + Ecto Telemetry Events&summary=description&source=http://localhost:4000" class="icon fa-linkedin"><span class="label">Linkedin</span></a></li>
  <li><a target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/intent/tweet?url=http://localhost:4000/blog/instrumenting_phoenix_with_telemetry_part_three/&via=elixirschool&text=ElixirSchool: Instrumenting Phoenix with Telemetry Part III: Phoenix + Ecto Telemetry Events&hashtags=learnelixir%2Celixirlang&" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
  <li><a target="_blank" rel="noopener" title="Facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/blog/instrumenting_phoenix_with_telemetry_part_three/" class="icon fa-facebook"><span class="label">Facebook</span></a></li>
  <li><a target="_blank" rel="noopener" title="Pinterest" href="https://www.pinterest.com/pin/create/link/?url=http://localhost:4000/blog/instrumenting_phoenix_with_telemetry_part_three/&media=http://localhost:4000/assets/og_image-fad975b316dea5dc361d199bdfaa076006da49a0a3296f799aa7217b4c8b0cbe.jpg&description=ElixirSchool: Instrumenting Phoenix with Telemetry Part III: Phoenix + Ecto Telemetry Events" class="icon fa-pinterest"><span class="label">Pinterest</span></a></li>
  <li><a target="_blank" rel="noopener" title="VK" href="https://vk.com/share.php?url=http://localhost:4000/blog/instrumenting_phoenix_with_telemetry_part_three/&title=ElixirSchool: Instrumenting Phoenix with Telemetry Part III: Phoenix + Ecto Telemetry Events&description=Check out 'Instrumenting Phoenix with Telemetry Part III: Phoenix + Ecto Telemetry Events' on ElixirSchool" class="icon fa-vk"><span class="label">VK</span></a></li>
  <li><a target="_blank" rel="noopener" title="Email" href="mailto:?to=&subject=ElixirSchool: Instrumenting Phoenix with Telemetry Part III: Phoenix + Ecto Telemetry Events&body=Check out 'Instrumenting Phoenix with Telemetry Part III: Phoenix + Ecto Telemetry Events' on ElixirSchool%0D%0A%0D%0Ahttp://localhost:4000/blog/instrumenting_phoenix_with_telemetry_part_three/" class="icon fa-envelope"><span class="label">Email</span></a></li>
  <li><a title="Print" href="javascript:window.print()" class="icon fa-print"><span class="label">Print</span></a></li>
</ul>

					</header>
					

<section id="section-page">
  <header class="main">
    <h1 class="post-title">Instrumenting Phoenix with Telemetry Part III: Phoenix + Ecto Telemetry Events</h1>
    <p><a href="/blog/years/2020/">06 May 2020</a> · by 

    <a href="https://thegreatcodeadventure.com" target="_blank" rel="nofollow noopener">Sophie DeBenedetto</a> in <a href="/blog/categories/general/">General</a></p>
  </header>
  <div class="content">
    <h2 id="table-of-contents">Table Of Contents</h2>

<p>In this series, we’re instrumenting a Phoenix app and sending metrics to StatsD with the help of Elixir and Erlang’s Telemetry offerings.</p>

<ul>
  <li><a href="https://elixirschool.com/blog/instrumenting-phoenix-with-telemetry-part-one/">Part I: Telemetry Under The Hood</a></li>
  <li><a href="https://elixirschool.com/blog/instrumenting_phoenix_with_telemetry_part_two/">Part II: Handling Telemetry Events with <code class="highlighter-rouge">TelemetryMetrics</code> + <code class="highlighter-rouge">TelemetryMetricsStatsd</code></a></li>
  <li>Part III: Observing Phoenix + Ecto Telemetry Events</li>
  <li><a href="https://elixirschool.com/blog/instrumenting-phoenix-with-telemetry-part-four/">Part IV: Erlang VM Measurements with <code class="highlighter-rouge">telemetry_poller</code>, <code class="highlighter-rouge">TelemetryMetrics</code> + <code class="highlighter-rouge">TelemetryMetricsStatsd</code></a></li>
</ul>

<h2 id="intro">Intro</h2>

<p>In the <a href="https://elixirschool.com/blog/instrumenting_phoenix_with_telemetry_part_two/">previous post</a>, we saw how the <code class="highlighter-rouge">Telemetry.Metrics</code> and <code class="highlighter-rouge">TelemetryMetricsStatsd</code> libraries abstracted away the need to define custom handlers, attach those handlers to events, and implement our own metric reporting logic. But our Telemetry pipeline still needs a little work–we’re still on the hook for emitting all of our own Telemetry events!</p>

<p>In order to really be able to observe the state of our production Phoenix app, we need to be reporting on much more than just one endpoint’s request duration and count. We need to report information-rich metrics describing web requests across the app, database queries, the behavior and state of the Erlang VM, the behavior and state of any workers in our app, and more.</p>

<p>Instrumenting all of that by hand, by executing custom Telemetry events wherever we need them, will be tedious and time-consuming. On top of that, it will be a challenge to standardize event naming conventions, measurements, and metadata across the app.</p>

<p>In this post, we’ll examine Phoenix and Ecto’s out-of-the-box Telemetry events and use <code class="highlighter-rouge">Telemetry.Metrics</code> to observe a wide-range of such events.</p>

<h2 id="achieving-observability-with-phoenix-and-ecto-telemetry-events">Achieving Observability with Phoenix and Ecto Telemetry Events</h2>

<p>To achieve observability, we know we nee to track things like:</p>

<ul>
  <li>Count and duration of all requests to all endpoints, with the ability to view this information broken down by things like:
    <ul>
      <li>Route</li>
      <li>Response status</li>
    </ul>
  </li>
  <li>Count and duration of all Ecto queries, with the ability to view this information broken down by things like:
    <ul>
      <li>Query command (e.g. <code class="highlighter-rouge">SELECT</code>, <code class="highlighter-rouge">UPDATE</code>)</li>
      <li>Table (e.g. <code class="highlighter-rouge">Users</code>)</li>
    </ul>
  </li>
</ul>

<p>Luckily for us, pretty much <em>all</em> of these events are already being emitted by Phoenix and Ecto directly!</p>

<p>In the following tutorial, we will teach <code class="highlighter-rouge">Telemetry.Metrics</code> to observe these out-of-the-box events and format the appropriate set of metrics, with information-rich tags, for each event.</p>

<h2 id="a-note-on-formatting-metrics">A Note On Formatting Metrics</h2>

<p>In our previous post, we used the <code class="highlighter-rouge">TelemetryMetricsStatsd</code> reporting library to format metrics and send them to StatsD over UDP. We can configure this reporter with either the standard formatter or the DogStatsD formatter. The standard formatter constructs and emits metrics that are compatible with the Etsy implementation of StatsD. This implementation does <em>not</em> support tagging, so <code class="highlighter-rouge">TelemetryMetricsStatsd</code> accommodates the tags we assign to metrics by including the tag values in the metric name.</p>

<p>For example, if we specify the following counter metric:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">counter</span><span class="p">(</span>
  <span class="s2">"phoenix.request"</span><span class="p">,</span>
  <span class="ss">tags:</span> <span class="p">[</span><span class="ss">:request_path</span><span class="p">]</span>
<span class="p">)</span>
</code></pre></div></div>

<p>And execute a Telemetry event where the <code class="highlighter-rouge">conn</code> we pass in for the metadata argument contains <code class="highlighter-rouge">%{request_path: "/register/new"}</code>, then <code class="highlighter-rouge">TelemetryMetricsStatsd</code> will construct a metric:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"phoenix.request.-register-new"
</code></pre></div></div>

<p>What if we ultimately want to send StatsD metrics to Datadog, which <em>does</em> support metric tagging? In that case, we can configure the <code class="highlighter-rouge">TelemetryMetricsStatsd</code> reporter to use the DogStatsD formatter, which would emit the following counter metric for the above event, including tags:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"phoenix.request:1|c|#request_path:/register/new"
</code></pre></div></div>

<p>For the purposes of this tutorial, we’ll use the DogStatsD formatter to make it easy to read and understand the metrics and tags that we are constructing and sending to StatsD.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Quantum</span><span class="o">.</span><span class="no">Telemetry</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Supervisor</span>
  <span class="kn">import</span> <span class="no">Telemetry</span><span class="o">.</span><span class="no">Metrics</span>

  <span class="k">def</span> <span class="n">start_link</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">Supervisor</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="ss">name:</span> <span class="bp">__MODULE__</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">init</span><span class="p">(</span><span class="n">_arg</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">[</span>
      <span class="p">{</span><span class="no">TelemetryMetricsStatsd</span><span class="p">,</span> <span class="ss">metrics:</span> <span class="n">metrics</span><span class="p">(),</span> <span class="ss">formatter:</span> <span class="ss">:datadog</span><span class="p">}</span> <span class="c1"># Add the formatter here!</span>
    <span class="p">]</span>

    <span class="no">Supervisor</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="ss">strategy:</span> <span class="ss">:one_for_one</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">defp</span> <span class="n">metrics</span> <span class="k">do</span>
    <span class="p">[</span>
      <span class="c1"># coming soon!</span>
    <span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="getting-started">Getting Started</h2>

<p>You can follow along with this tutorial by cloning down the repo [here]
(https://github.com/elixirschool/telemetry-code-along/tree/part-3-start).</p>
<ul>
  <li>Checking out the starting state of our code on the branch <a href="https://github.com/elixirschool/telemetry-code-along/tree/part-3-start">part-3-start</a></li>
  <li>Find the solution code on the branch <a href="https://github.com/elixirschool/telemetry-code-along/tree/part-3-solution">part-3-solution</a></li>
</ul>

<h2 id="phoenix-telemetry-events">Phoenix Telemetry Events</h2>

<h3 id="the-phoenix-router_dispatch-stop-event">The <code class="highlighter-rouge">[:phoenix, :router_dispatch, :stop]</code> Event</h3>

<p>First up, we’ll leverage one of the out-of-the-box Phoenix events to help us track and report metrics for web request counts and durations–the <code class="highlighter-rouge">[:phoenix, :router_dispatch, :stop]</code> event.</p>

<p>The <code class="highlighter-rouge">Phoenix.Router</code> module executes this event after the request is processed by the Plug pipeline and the controller, but <em>before</em> a response is rendered. Looking in Phoenix source code we can see the event being emitted <a href="https://github.com/phoenixframework/phoenix/blob/d4596650df21e7e0603debcb5f2ad25eb9ac082d/lib/phoenix/router.ex#L357">here</a>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># phoenix/lib/phoenix/router.ex</span>

<span class="n">duration</span> <span class="o">=</span> <span class="no">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="p">%{</span><span class="n">metadata</span> <span class="o">|</span> <span class="ss">conn:</span> <span class="n">conn</span><span class="p">}</span>
<span class="ss">:telemetry</span><span class="o">.</span><span class="n">execute</span><span class="p">([</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="ss">:router_dispatch</span><span class="p">,</span> <span class="ss">:stop</span><span class="p">],</span> <span class="p">%{</span><span class="ss">duration:</span> <span class="n">duration</span><span class="p">},</span> <span class="n">metadata</span><span class="p">)</span>
</code></pre></div></div>

<p>Here, Phoenix is calculating the duration by subtracting the start time, set at the beginning of the request processing pipeline, from the current time. Then it’s updating the metadata map to include the <code class="highlighter-rouge">conn</code>. Lastly, it’s executing the Telemetry metric with this information.</p>

<p>Now that we know which Telemetry event we care about, let’s make our <code class="highlighter-rouge">Telemetry.Metrics</code>, <code class="highlighter-rouge">Quantum.Telemetry</code> module aware of it.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/quantum/telemetry.ex</span>

<span class="k">def</span> <span class="n">metrics</span> <span class="k">do</span>
  <span class="p">[</span>
    <span class="n">summary</span><span class="p">(</span>
      <span class="s2">"phoenix.router_dispatch.stop.duration"</span><span class="p">,</span>
      <span class="ss">unit:</span> <span class="p">{</span><span class="ss">:native</span><span class="p">,</span> <span class="ss">:millisecond</span><span class="p">},</span>
      <span class="ss">tags:</span> <span class="p">[</span><span class="ss">:plug</span><span class="p">,</span> <span class="ss">:plug_opts</span><span class="p">]</span>
    <span class="p">),</span>

    <span class="n">counter</span><span class="p">(</span>
      <span class="s2">"phoenix.router_dispatch.stop.count"</span><span class="p">,</span>
      <span class="ss">tags:</span> <span class="p">[</span><span class="ss">:plug</span><span class="p">,</span> <span class="ss">:plug_opts</span><span class="p">]</span>
    <span class="p">)</span>
  <span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now, whenever the <code class="highlighter-rouge">Phoenix.Router</code> executes the <code class="highlighter-rouge">[:phoenix, :router_dispatch, :stop]</code> Telemetry event for a given web request, we will see counter and timer metrics emitted to StatsD tagged with the <code class="highlighter-rouge">:plug</code> and <code class="highlighter-rouge">:plug_opts</code> values from the event metadata.</p>

<p>By running the app and visiting the landing page, we see the following reported to StatsD:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># timing
"phoenix.router_dispatch.stop.duration:5.411|ms|#plug:Elixir.QuantumWeb.PageController,plug_opts:index"

# counter
"phoenix.router_dispatch.stop.count:1|c|#plug:Elixir.QuantumWeb.PageController,plug_opts:index"
</code></pre></div></div>

<p>This represents a BIG win for us, as compared to our previous approach of manually executing a Telemetry event from <em>every controller action in our app</em>. By defining metrics for this event in our <code class="highlighter-rouge">Quantum.Telemetry</code> module and providing those metrics to the <code class="highlighter-rouge">TelemetryMetricsStatsd</code> reporter, we are able to report metrics for every web request our app receives, across all endpoints.</p>

<h3 id="getting-more-out-of-tags">Getting More Out Of Tags</h3>

<p>We can also see how helpful the <code class="highlighter-rouge">:tags</code> option of the metrics functions can be. These tags are ensuring that the metrics we report to StatsD are information-rich–they contain data from the context of the web request. Recall from the previous post that the <code class="highlighter-rouge">TelemetryMetricsStatsd</code> reporter will apply tags for a given metric where those tags are present as keys in the event metadata. So, when <code class="highlighter-rouge">Phoenix.Router</code> executes the following Telemetry event:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># phoenix/lib/phoenix/router.ex</span>

<span class="n">duration</span> <span class="o">=</span> <span class="no">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="p">%{</span><span class="n">metadata</span> <span class="o">|</span> <span class="ss">conn:</span> <span class="n">conn</span><span class="p">}</span>
<span class="ss">:telemetry</span><span class="o">.</span><span class="n">execute</span><span class="p">([</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="ss">:router_dispatch</span><span class="p">,</span> <span class="ss">:stop</span><span class="p">],</span> <span class="p">%{</span><span class="ss">duration:</span> <span class="n">duration</span><span class="p">},</span> <span class="n">metadata</span><span class="p">)</span>
</code></pre></div></div>

<p>It provides the <code class="highlighter-rouge">:telemetry.execute/3</code> call with <code class="highlighter-rouge">metadata</code> that includes top-level keys of <code class="highlighter-rouge">:plug</code> and <code class="highlighter-rouge">:plug_opts</code>.</p>

<p>It <em>also</em> includes the request <code class="highlighter-rouge">conn</code> in that metadata map, under a key of <code class="highlighter-rouge">:conn</code>. What if we want to grab some data out of the <code class="highlighter-rouge">conn</code> to include in our metric tags?</p>

<p>It would be great if we could tag these web request counter metrics with the response status–that way we can aggregate counts of successful and failed web requests.</p>

<p>The response status <em>is</em> present in the <code class="highlighter-rouge">conn</code>, under a key of <code class="highlighter-rouge">:status</code>. But the <code class="highlighter-rouge">Telemetry.Metrics.counter/2</code> function only knows how to deal with tags that are top-level in the provided <code class="highlighter-rouge">metadata</code>. If only there was some way to tell the counter metric how to apply tags from data that is <em>nested inside</em> the provided metadata.</p>

<p>This is where the metrics functions’ <code class="highlighter-rouge">:tag_values</code> option comes in! We can use the <code class="highlighter-rouge">:tag_values</code> option to store a function that will be called later on during the Telemetry event handling process to construct additional tags from nested metadata info.</p>

<p>All <em>we</em> have to do is implement a function that expects to receive the event metadata and returns a map that includes all of the tags we want to apply to our metric:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/quantum/telemetry.ex</span>

<span class="k">def</span> <span class="n">endpoint_metadata</span><span class="p">(%{</span><span class="ss">conn:</span> <span class="p">%{</span><span class="ss">status:</span> <span class="n">status</span><span class="p">},</span> <span class="ss">plug:</span> <span class="n">plug</span><span class="p">,</span> <span class="ss">plug_opts:</span> <span class="n">plug_opts</span><span class="p">})</span> <span class="k">do</span>
  <span class="p">%{</span><span class="ss">status:</span> <span class="n">status</span><span class="p">,</span> <span class="ss">plug:</span> <span class="n">plug</span><span class="p">,</span> <span class="ss">plug_opts:</span> <span class="n">plug_opts</span><span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Then, when we call a given metrics function, for example <code class="highlighter-rouge">counter/2</code>, we set  the <code class="highlighter-rouge">:tag_values</code> option to this function and <code class="highlighter-rouge">:tags</code> to our complete list of tags:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/quantum/telemetry.ex</span>

<span class="k">def</span> <span class="n">metrics</span> <span class="k">do</span>
  <span class="p">[</span>
    <span class="n">counter</span><span class="p">(</span>
      <span class="s2">"phoenix.router_dispatch.stop.count"</span><span class="p">,</span>
      <span class="ss">tag_values:</span> <span class="o">&amp;</span><span class="bp">__MODULE__</span><span class="o">.</span><span class="n">endpoint_metadata</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>
      <span class="ss">tags:</span> <span class="p">[</span><span class="ss">:plug</span><span class="p">,</span> <span class="ss">:plug_opts</span><span class="p">,</span> <span class="ss">:status</span><span class="p">]</span>
    <span class="p">)</span>
  <span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now, when we run our Phoenix server and visit the landing page, we see the following counter metric emitted to StatsD:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"phoenix.router_dispatch.stop.count:1|c|#plug:Elixir.QuantumWeb.PageController,plug_opts:index,status:200"
</code></pre></div></div>

<p>Notice that now the metric is tagged with the response status. This will make it easy for us to visualize counts of failed and successful requests in Datadog.</p>

<h3 id="more-phoenix-telemetry-events">More Phoenix Telemetry Events</h3>

<p>So far, we’ve taken advantage of just one of several Telemetry events executed by Phoenix source code. There are a number of helpful events we can have our Telemetry pipeline handle. Let’s take a brief look at some of these events now.</p>

<h4 id="the-phoenix-error_rendered-telemetry-event">The <code class="highlighter-rouge">[:phoenix, :error_rendered]</code> Telemetry Event</h4>

<p>The <code class="highlighter-rouge">Phoenix.Endpoint.RenderErrors</code> module executes a Telemetry event after rendering the error view. We can see the call to execute this event in source code <a href="https://github.com/phoenixframework/phoenix/blob/00a022fbbf25a9d0845329161b1bc1a192c2d407/lib/phoenix/endpoint/render_errors.ex#L81">here</a>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># phoenix/lib/phoenix/endpoint/render_errors.ex</span>

<span class="k">defp</span> <span class="n">instrument_render_and_send</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">start</span> <span class="o">=</span> <span class="no">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span>
  <span class="n">metadata</span> <span class="o">=</span> <span class="p">%{</span><span class="ss">status:</span> <span class="n">status</span><span class="p">,</span> <span class="ss">kind:</span> <span class="n">kind</span><span class="p">,</span> <span class="ss">reason:</span> <span class="n">reason</span><span class="p">,</span> <span class="ss">stacktrace:</span> <span class="n">stack</span><span class="p">,</span> <span class="ss">log:</span> <span class="n">level</span><span class="p">}</span>

  <span class="k">try</span> <span class="k">do</span>
    <span class="n">render</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>
  <span class="k">after</span>
    <span class="n">duration</span> <span class="o">=</span> <span class="no">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="ss">:telemetry</span><span class="o">.</span><span class="n">execute</span><span class="p">([</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="ss">:error_rendered</span><span class="p">],</span> <span class="p">%{</span><span class="ss">duration:</span> <span class="n">duration</span><span class="p">},</span> <span class="n">metadata</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We can tell our Telemetry pipeline to handle this event as a counter and tag it with the request path and response status in our <code class="highlighter-rouge">Quantum.Telemetry.metrics/0</code> function like this:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/quantum/telemetry.ex</span>

<span class="k">def</span> <span class="n">metrics</span> <span class="k">do</span>
  <span class="p">[</span>
    <span class="n">counter</span><span class="p">(</span>
      <span class="s2">"phoenix.error_rendered.count"</span><span class="p">,</span>
      <span class="ss">tag_values:</span> <span class="o">&amp;</span><span class="bp">__MODULE__</span><span class="o">.</span><span class="n">error_request_metadata</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>
      <span class="ss">tags:</span> <span class="p">[</span><span class="ss">:request_path</span><span class="p">,</span> <span class="ss">:status</span><span class="p">]</span>
    <span class="p">)</span>
  <span class="p">]</span>
<span class="k">end</span>

<span class="k">def</span> <span class="n">error_request_metadata</span><span class="p">(%{</span><span class="ss">conn:</span> <span class="p">%{</span><span class="ss">request_path:</span> <span class="n">request_path</span><span class="p">},</span> <span class="ss">status:</span> <span class="n">status</span><span class="p">})</span> <span class="k">do</span>
  <span class="p">%{</span><span class="ss">status:</span> <span class="n">status</span><span class="p">,</span> <span class="ss">request_path:</span> <span class="n">request_path</span><span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now, we’ll see the following counter metric incremented in StatsD when a user visits, <code class="highlighter-rouge">/blah</code>, a path that does not exist:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"phoenix.error_rendered.count:1|c|#request_path:blah,status:404"
</code></pre></div></div>

<h4 id="phoenixsocket-telemetry-event"><code class="highlighter-rouge">Phoenix.Socket</code> Telemetry Event</h4>

<p>Phoenix also provides some out-of-the-box instrumentation for Socket and Channel interactions.</p>

<p>The <code class="highlighter-rouge">Phoenix.Socket</code> module executes a Telemetry event whenever the socket is connected to. We can see that event in source code <a href="https://github.com/phoenixframework/phoenix/blob/e83b6291cb4ed7cd6572b7af274842910667ade3/lib/phoenix/socket.ex#L450">here</a>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># phoenix/lib/phoenix/socket.ex</span>
<span class="k">def</span> <span class="n">__connect__</span><span class="p">(</span><span class="n">user_socket</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">socket_options</span><span class="p">)</span> <span class="k">do</span>
  <span class="p">%{</span>
    <span class="ss">endpoint:</span> <span class="n">endpoint</span><span class="p">,</span>
    <span class="ss">options:</span> <span class="n">options</span><span class="p">,</span>
    <span class="ss">transport:</span> <span class="n">transport</span><span class="p">,</span>
    <span class="ss">params:</span> <span class="n">params</span><span class="p">,</span>
    <span class="ss">connect_info:</span> <span class="n">connect_info</span>
  <span class="p">}</span> <span class="o">=</span> <span class="n">map</span>

  <span class="n">start</span> <span class="o">=</span> <span class="no">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span>

  <span class="k">case</span> <span class="n">negotiate_serializer</span><span class="p">(</span><span class="no">Keyword</span><span class="o">.</span><span class="n">fetch!</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="ss">:serializer</span><span class="p">),</span> <span class="n">vsn</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">serializer</span><span class="p">}</span> <span class="o">-&gt;</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">user_connect</span><span class="p">(</span><span class="n">user_socket</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="n">serializer</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">connect_info</span><span class="p">)</span>

      <span class="n">metadata</span> <span class="o">=</span> <span class="p">%{</span>
        <span class="ss">endpoint:</span> <span class="n">endpoint</span><span class="p">,</span>
        <span class="ss">transport:</span> <span class="n">transport</span><span class="p">,</span>
        <span class="ss">params:</span> <span class="n">params</span><span class="p">,</span>
        <span class="ss">connect_info:</span> <span class="n">connect_info</span><span class="p">,</span>
        <span class="ss">vsn:</span> <span class="n">vsn</span><span class="p">,</span>
        <span class="ss">user_socket:</span> <span class="n">user_socket</span><span class="p">,</span>
        <span class="ss">log:</span> <span class="no">Keyword</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="ss">:log</span><span class="p">,</span> <span class="ss">:info</span><span class="p">),</span>
        <span class="ss">result:</span> <span class="n">result</span><span class="p">(</span><span class="n">result</span><span class="p">),</span>
        <span class="ss">serializer:</span> <span class="n">serializer</span>
      <span class="p">}</span>

      <span class="n">duration</span> <span class="o">=</span> <span class="no">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
      <span class="ss">:telemetry</span><span class="o">.</span><span class="n">execute</span><span class="p">([</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="ss">:socket_connected</span><span class="p">],</span> <span class="p">%{</span><span class="ss">duration:</span> <span class="n">duration</span><span class="p">},</span> <span class="n">metadata</span><span class="p">)</span>
      <span class="n">result</span>

    <span class="ss">:error</span> <span class="o">-&gt;</span>
      <span class="ss">:error</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We can see that the event is executed with the duration measurement and a metadata map that includes the connection params and other contextual info. We can tell our Telemetry pipeline to handle this event by adding metrics for the <code class="highlighter-rouge">"phoenix.socket_connected"</code> event in our <code class="highlighter-rouge">Quantum.Telemetry.metrics/0</code> list:</p>

<p>For example:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/quantum/telemetry.ex</span>

<span class="k">def</span> <span class="n">metrics</span> <span class="k">do</span>
  <span class="p">[</span>
    <span class="n">counter</span><span class="p">(</span>
      <span class="s2">"phoenix.socket_connected.count"</span><span class="p">,</span>
      <span class="ss">tags:</span> <span class="p">[</span><span class="ss">:endpoint</span><span class="p">]</span>
    <span class="p">)</span>
  <span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now we will increment a StatsD metric every time the socket is joined.</p>

<h3 id="phoenixchannel-telemetry-events"><code class="highlighter-rouge">Phoenix.Channel</code> Telemetry Events</h3>

<p>The <code class="highlighter-rouge">Phoenix.Channel.Server</code> module executes two Telemetry events–one when the channel is joined and one whenever the channel invokes <code class="highlighter-rouge">handle_info/2</code>.</p>

<p>We can see the <code class="highlighter-rouge">[:phoenix, :channel_joined]</code> Telemetry event in source code <a href="https://github.com/phoenixframework/phoenix/blob/8a4aa4eed0de69f94ab09eca157c87d9bd204168/lib/phoenix/channel/server.ex#L302">here</a>:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># phoenix/lib/phoenix/channel/server.ex</span>

<span class="k">def</span> <span class="n">handle_info</span><span class="p">({</span><span class="ss">:join</span><span class="p">,</span> <span class="bp">__MODULE__</span><span class="p">},</span> <span class="p">{</span><span class="n">auth_payload</span><span class="p">,</span> <span class="p">{</span><span class="n">pid</span><span class="p">,</span> <span class="n">_</span><span class="p">}</span> <span class="o">=</span> <span class="n">from</span><span class="p">,</span> <span class="n">socket</span><span class="p">})</span> <span class="k">do</span>
  <span class="p">%{</span><span class="ss">channel:</span> <span class="n">channel</span><span class="p">,</span> <span class="ss">topic:</span> <span class="n">topic</span><span class="p">,</span> <span class="ss">private:</span> <span class="n">private</span><span class="p">}</span> <span class="o">=</span> <span class="n">socket</span>

  <span class="n">start</span> <span class="o">=</span> <span class="no">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span>
  <span class="p">{</span><span class="n">reply</span><span class="p">,</span> <span class="n">state</span><span class="p">}</span> <span class="o">=</span> <span class="n">channel_join</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">topic</span><span class="p">,</span> <span class="n">auth_payload</span><span class="p">,</span> <span class="n">socket</span><span class="p">)</span>
  <span class="n">duration</span> <span class="o">=</span> <span class="no">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
  <span class="n">metadata</span> <span class="o">=</span> <span class="p">%{</span><span class="ss">params:</span> <span class="n">auth_payload</span><span class="p">,</span> <span class="ss">socket:</span> <span class="n">socket</span><span class="p">,</span> <span class="ss">result:</span> <span class="n">elem</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}</span>
  <span class="ss">:telemetry</span><span class="o">.</span><span class="n">execute</span><span class="p">([</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="ss">:channel_joined</span><span class="p">],</span> <span class="p">%{</span><span class="ss">duration:</span> <span class="n">duration</span><span class="p">},</span> <span class="n">metadata</span><span class="p">)</span>
  <span class="no">GenServer</span><span class="o">.</span><span class="n">reply</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">reply</span><span class="p">)</span>
  <span class="n">state</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And we can see the <code class="highlighter-rouge">[:phoenix, channel_handled_in]</code> event <a href="https://github.com/phoenixframework/phoenix/blob/8a4aa4eed0de69f94ab09eca157c87d9bd204168/lib/phoenix/channel/server.ex#L319">here</a></p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># phoenix/lib/phoenix/channel/server.ex</span>

<span class="k">def</span> <span class="n">handle_info</span><span class="p">(</span>
    <span class="p">%</span><span class="no">Message</span><span class="p">{</span><span class="ss">topic:</span> <span class="n">topic</span><span class="p">,</span> <span class="ss">event:</span> <span class="n">event</span><span class="p">,</span> <span class="ss">payload:</span> <span class="n">payload</span><span class="p">,</span> <span class="ss">ref:</span> <span class="n">ref</span><span class="p">},</span>
    <span class="p">%{</span><span class="ss">topic:</span> <span class="n">topic</span><span class="p">}</span> <span class="o">=</span> <span class="n">socket</span>
  <span class="p">)</span> <span class="k">do</span>
  <span class="n">start</span> <span class="o">=</span> <span class="no">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">handle_in</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">put_in</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="n">ref</span><span class="p">))</span>
  <span class="n">duration</span> <span class="o">=</span> <span class="no">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
  <span class="n">metadata</span> <span class="o">=</span> <span class="p">%{</span><span class="ss">ref:</span> <span class="n">ref</span><span class="p">,</span> <span class="ss">event:</span> <span class="n">event</span><span class="p">,</span> <span class="ss">params:</span> <span class="n">payload</span><span class="p">,</span> <span class="ss">socket:</span> <span class="n">socket</span><span class="p">}</span>

  <span class="ss">:telemetry</span><span class="o">.</span><span class="n">execute</span><span class="p">([</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="ss">:channel_handled_in</span><span class="p">],</span> <span class="p">%{</span><span class="ss">duration:</span> <span class="n">duration</span><span class="p">},</span> <span class="n">metadata</span><span class="p">)</span>

  <span class="n">handle_in</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We can add some metrics reporting for these events by defining metrics in <code class="highlighter-rouge">Quantum.Telemetry</code> for either of the <code class="highlighter-rouge">"phoenix.channel_joined"</code> and <code class="highlighter-rouge">"phoenix.channel_handled_in"</code> events.</p>

<p>Now that we’ve taken a brief tour of Phoenix Telemetry events, let’s hook up some reporting for Ecto events.</p>

<h2 id="ecto-telemetry-events">Ecto Telemetry Events</h2>

<p>Ecto provides some out-of-the-box instrumentation for queries. Let’s take a look at and define metrics for some of these Telemetry events now.</p>

<p>Ecto will execute a Telemetry event, <a href="https://github.com/elixir-ecto/ecto/blob/2aca7b28eef486188be66592055c7336a80befe9/lib/ecto/repo.ex#L120"><code class="highlighter-rouge">[:my_app, :repo, :query]</code></a> for every query sent to the Ecto adapter. It will emit this event with a measurement map and a metadata map.</p>

<p>The measurement map will include:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* `:idle_time` - the time the connection spent waiting before being checked out for the query
* `:queue_time` - the time spent waiting to check out a database connection
* `:query_time` - the time spent executing the query
* `:decode_time` - the time spent decoding the data received from the database
* `:total_time` - the sum of the other measurements
</code></pre></div></div>

<p>The metadata map will includes:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* `:type` - the type of the Ecto query. For example, for Ecto.SQL
    databases, it would be `:ecto_sql_query`
* `:repo` - the Ecto repository
* `:result` - the query result
* `:params` - the query parameters
* `:query` - the query sent to the database as a string
* `:source` - the source the query was made on (may be nil)
* `:options` - extra options given to the repo operation under
  `:telemetry_options`
</code></pre></div></div>

<p>If we want to establish metrics for Ecto query counts aggregated by table and command, we could establish the following metric in our <code class="highlighter-rouge">Quantum.Telemetry</code> metrics list:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">metrics</span> <span class="k">do</span>
  <span class="p">[</span>
    <span class="n">counter</span><span class="p">(</span>
      <span class="s2">"quantum.repo.query.count"</span><span class="p">,</span>
      <span class="ss">tag_values:</span> <span class="o">&amp;</span><span class="bp">__MODULE__</span><span class="o">.</span><span class="n">query_metatdata</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>
      <span class="ss">tags:</span> <span class="p">[</span><span class="ss">:source</span><span class="p">,</span> <span class="ss">:command</span><span class="p">]</span>
    <span class="p">)</span>
  <span class="p">]</span>
<span class="k">end</span>

<span class="k">def</span> <span class="n">query_metatdata</span><span class="p">(%{</span><span class="ss">source:</span> <span class="n">source</span><span class="p">,</span> <span class="ss">result:</span> <span class="p">{</span><span class="n">_</span><span class="p">,</span> <span class="p">%{</span><span class="ss">command:</span> <span class="n">command</span><span class="p">}}})</span> <span class="k">do</span>
  <span class="p">%{</span><span class="ss">source:</span> <span class="n">source</span><span class="p">,</span> <span class="ss">command:</span> <span class="n">command</span><span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This will increment a counter in StatsD for each query to a given table with a given command. For example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"quantum.repo.query:1|c|#source:users,command:select"
</code></pre></div></div>

<p>We can also establish a timing metric with the use of the <code class="highlighter-rouge">summary</code> metric function:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">metrics</span> <span class="k">do</span>
  <span class="p">[</span>
    <span class="n">summary</span><span class="p">(</span>
      <span class="s2">"quantum.repo.query.total_time"</span><span class="p">,</span>
      <span class="ss">unit:</span> <span class="p">{</span><span class="ss">:native</span><span class="p">,</span> <span class="ss">:millisecond</span><span class="p">},</span>
      <span class="ss">tag_values:</span> <span class="o">&amp;</span><span class="bp">__MODULE__</span><span class="o">.</span><span class="n">query_metadata</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>
      <span class="ss">tags:</span> <span class="p">[</span><span class="ss">:source</span><span class="p">,</span> <span class="ss">:command</span><span class="p">]</span>
    <span class="p">)</span>
  <span class="p">]</span>
<span class="k">end</span>

<span class="k">def</span> <span class="n">query_metadata</span><span class="p">(%{</span><span class="ss">source:</span> <span class="n">source</span><span class="p">,</span> <span class="ss">result:</span> <span class="p">{</span><span class="n">_</span><span class="p">,</span> <span class="p">%{</span><span class="ss">command:</span> <span class="n">command</span><span class="p">}}})</span> <span class="k">do</span>
  <span class="p">%{</span><span class="ss">source:</span> <span class="n">source</span><span class="p">,</span> <span class="ss">command:</span> <span class="n">command</span><span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This will report timing metrics to StatsD for each query executed with a given command to a given table. For example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"quantum.repo.query.total_time:1.7389999999999999|ms|#source:users,command:select"
</code></pre></div></div>

<h2 id="more-metrics">More Metrics</h2>

<p>This post has mainly focused on the <code class="highlighter-rouge">counter/2</code> and <code class="highlighter-rouge">summary/2</code> <code class="highlighter-rouge">Telemetry.Metrics</code> functions, corresponding to the “count” and “timing” StatsD metric type respectively. <code class="highlighter-rouge">Telemetry.Metrics</code> implements five metrics functions, each of which map to a specific metric type. To learn how to define and report on these various metric types, check out the docs <a href="https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html#module-metrics">here</a> and <a href="https://hexdocs.pm/telemetry_metrics_statsd/TelemetryMetricsStatsd.html">here</a></p>

<h2 id="conclusion">Conclusion</h2>

<p>Instrumenting our Phoenix app by taking advantage of the Telemetry events that are executed for us by Phoenix and Ecto allowed us to achieve a high degree of observability without writing a lot of custom code.</p>

<p>We simply defined our <code class="highlighter-rouge">Telemetry.Metrics</code> module, configured it to start up the <code class="highlighter-rouge">TelemetryMetricsStatsd</code> reporter and defined the list of existing Telemetry events to observe as metrics. Now we’re reporting a valuable set of information-rich metrics to StatsD, formatted for Datadog, without manually executing a single Telemetry event or defining any of our own event handlers.</p>

<h2 id="next-up">Next Up</h2>

<p>There’s one more flavor of out-of-the-box metrics reporting we’ll explore in this series. In our <a href="https://elixirschool.com/blog/instrumenting-phoenix-with-telemetry-part-four/">next post</a>, we’ll use the <code class="highlighter-rouge">telemetry_poller</code> Erlang library to emit Erlang VM measurements as Telemetry events and we’ll use <code class="highlighter-rouge">Telemetry.Metrics</code> and <code class="highlighter-rouge">TelemetryMetricsStatsd</code> to observe and report those events as metrics.</p>

    

    <blockquote class="edit-lesson">
      Caught a mistake or want to contribute to the article?
      <a href="https://github.com/elixirschool/elixirschool/edit/master/_posts/2020-05-06-instrumenting_phoenix_with_telemetry_part_three.md" target="_blank" rel="noopener">
        Edit this page on GitHub!
      </a>
    </blockquote>
  </div>
</section>
<section class="section-prevnext">
  <div class="row">
    <div class="6u 12u$(small)">
      
        <h4 class="title is-7 has-text-grey-light">Previous article</h4>
        <a class="button special fit" href="http://localhost:4000/blog/instrumenting_phoenix_with_telemetry_part_two/" title="Instrumenting Phoenix with Telemetry Part II: Telemetry Metrics + Reporters" rel="prev">&laquo; Instrumenting Phoenix with Telemetry Part II: T...</a>
      
    </div>
    <div class="6u 12u$(small)">
      
        <h4>Next article</h4>
        <a class="button special fit" href="http://localhost:4000/blog/instrumenting-phoenix-with-telemetry-part-four/" title="Instrumenting Phoenix with Telemetry Part IV: Erlang VM Measurements with `telemetry_poller`" rel="next">Instrumenting Phoenix with Telemetry Part IV: E... &raquo;</a>
      
    </div>
  </div>
</section>

<section>

    
  
    <div class="row profile">
  <div class="1u 2u(medium) 12u$(small)"><img src="https://github.com/SophieDeBenedetto.png" alt="" style="max-width: 60px;"></div>
  <div class="11u 10u(medium) 12u$(small)">
    <h2>
    
      <a href="https://github.com/SophieDeBenedetto">Sophie DeBenedetto</a>
    
    </h2>
    <p class="content">Sophie is an engineer and teacher at The Flatiron School. She loves teaching and learning and finding the Elixir School community felt like the perfect fit!</p>
    <ul class="icons">
      
      <li><a href="https://thegreatcodeadventure.com" class="icon fa-globe"><span class="label">Homepage</span></a></li>
      
      
      <li><a href="https://twitter.com/sm_debenedetto" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
      
      <li><a href="https://github.com/SophieDeBenedetto" class="icon fa-github"><span class="label">Github</span></a></li>
    </ul>
  </div>
</div>

  
</section>

				</div>
			</div>
			<!-- Sidebar -->
  <div id="sidebar">
    <p class="toggle-theme-wrapper"><a rel="noopener" href="#toggle-theme" class="toggle-theme icon fas fa-circle-o" alt="Toggle Theme" title="Toggle Theme"></a></p>

    <div class="inner">
      

      
<!-- Menu -->
<nav id="menu">
  <span class="stack-info otp-version">Elixir 1.10.1 - Erlang/OTP 22.0 [erts-10.5.3]</span>
  <header class="major">
    <h2></h2>
    <p>The premier destination for learning and mastering Elixir</p>
  </header>
  <ul>
    <li>
      <a href="/" class=" up ">Home</a>
    </li>
  
    
    
    
    
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Basics</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/basics/basics/">1. Basics</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/collections/">2. Collections</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/enum/">3. Enum</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/pattern-matching/">4. Pattern Matching</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/control-structures/">5. Control Structures</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/functions/">6. Functions</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/pipe-operator/">7. Pipe Operator</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/modules/">8. Modules</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/mix/">9. Mix</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/sigils/">10. Sigils</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/documentation/">11. Documentation</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/testing/">12. Testing</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/comprehensions/">13. Comprehensions</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/strings/">14. Strings</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/date-time/">15. Date and Time</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/mix-tasks/">16. Custom Mix Tasks</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/basics/iex-helpers/">17. IEx Helpers</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Advanced</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/advanced/erlang/">1. Erlang Interoperability</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/error-handling/">2. Error Handling</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/escripts/">3. Executables</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/concurrency/">4. Concurrency</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/otp-concurrency/">5. OTP Concurrency</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/otp-supervisors/">6. OTP Supervisors</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/otp-distribution/">7. OTP Distribution</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/metaprogramming/">8. Metaprogramming</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/umbrella-projects/">9. Umbrella Projects</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/typespec/">10. Specifications and types</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/behaviours/">11. Behaviours</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/gen-stage/">12. GenStage</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/advanced/protocols/">13. Protocols</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Ecto</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/ecto/basics/">1. Basics</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/ecto/changesets/">2. Changesets</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/ecto/associations/">3. Associations</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/ecto/querying/">4. Querying</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Specifics</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/specifics/plug/">1. Plug</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/eex/">2. Embedded Elixir (EEx)</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/ets/">3. Erlang Term Storage (ETS)</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/mnesia/">4. Mnesia</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/debugging/">5. Debugging</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/specifics/nerves/">6. Nerves</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    
    
    
    
    
      
        
        <li>
          <span class="opener up">Libraries</span>
          <ul>
        
            <li>
              
              <a href="/en/lessons/libraries/guardian/">1. Guardian (Basics)</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/poolboy/">2. Poolboy</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/benchee/">3. Benchee</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/bypass/">4. Bypass</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/distillery/">5. Distillery (Basics)</a>
              
            </li>
        
      
        
            <li>
              
              <a href="/en/lessons/libraries/stream-data/">6. StreamData</a>
              
            </li>
        
          </ul>
        </li>
        
      
    
  
    <li>
      <a href="/blog/" class=" up active">Blog</a>
    </li>
    
    <li>
      <a href="/contributors/" class=" up ">Contributors</a>
    </li>
  </ul>
</nav>

      <!-- Footer -->
      <footer id="footer">
        <p class="copyright">&copy; 2021 <a target="_blank" rel="noopener" href="https://github.com/doomspork">Sean Callan</a> All rights reserved.</p>
      </footer>
    </div>
  </div>

		</div>
		<!-- Scripts -->

    <script async="" src="/assets/main-f8c201d2721dcb6d1d4f6acb0ebd2b2c192757ed29271f519513e4417e347611.js" type="text/javascript"></script>
		<!--[if lte IE 8]><script async="" src="/assets/ie/respond.min-8306093ccce666c01dab405fac0d16596a1d1cf38aa0ba919d4831261662cdbb.js" type="text/javascript"></script><script src="assets/js/ie/respond.min.js"></script><![endif]-->
	</body>
</html>
